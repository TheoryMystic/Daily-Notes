* TODO [#A] 3D Math Primer
** Chapter 1 Cartesian Coordinate Systems[笛卡尔坐标系]
   3D math is all about measuring *locations*, *distances* and *angles* precisely and
   mathematically in 3D space.
   3D数学是关于如何在3维空间中精确测量 *位置*, *距离* 和 *角度* 的学科.

*** 1.1 1D Mathematics[1D数学]
    natural numbers[自然数]  
    --> A numbers line for the natural numbers[数轴]
    --> negative numbers[负数] 
    --> fractional numbers[分数]  
    --> rational numbers[有理数]
    --> real numbers[实数] [fn:real_number]
    --> discrete mathematics[离散数学] (study of natural numbers and integers)
    --> continuous mathematics[连续数学] (study of real numbers)

    _The First Law of Computer Graphics_
    If it _looks_ right, it _is_ right.

*** 1.2 2D Cartesian Space[2D笛卡尔空间]
    *origin*[原点]  --> 坐标(0,0)
    *axis*[轴] --> 穿过原点并且互相 *垂直*[perpendicular]的直线.
    *Cartesian coordinates*[笛卡尔坐标系] --> 由两个 *点* 来指明
    一个 *位置*[location].
    *signed distance*[有符号距离] --> 表示坐标点的x,y值分别到y,x轴
    的距离.(根据方向判断正负)

*** 1.3 3D Cartesian Space[3D笛卡尔空间]
    *Plane*[平面],就是由两条不平行的线张成的空间.
    与2D坐标系不同,3D笛卡尔空间的x,y,z轴并没有标准的定义.
    在2D坐标系中,x轴正方向向右,y轴正方向向上.
    而在3D笛卡尔空间中,指定了两种x,y,z轴位置的方法.
    一个是 *左手坐标系*[Left-handed],一个是 *右手坐标系*[Right-handed].
    在标准3D坐标系中,当:
    x -> 右 y ->上 z-> 外   -----> 左手坐标系
    x -> 右 y ->上 z-> 里   -----> 右手坐标系
    判断任意坐标系是左手还是右手时,将该坐标系旋转到标准坐标系,再根据z轴指向确定
    具体是左手还是右手坐标系.
       
*** 1.4 Odds and Ends[其他东西]
    *Summation Notation*[连加] -->  Σ
    *Product Notation*[连乘] -->  ∏
    *Interval Notation* [区间] -->  [a,b]   (a,b]   (a,b)
**** Angles,Degrees,and Radians[角,角度与弧度]
    *angle* --> an angle measures an amount of rotation in the plane.
    角表示的是 _对平面上旋转大小的度量_. 通常用希腊文θ表示.
    角有两种 *单位*[units],一种是 *degree*[角度°],另一种是 *radians*[弧度rad].
    πrad = 180°, 
    1 rad = (180/π)° , 1° = (π/180)rad.
**** Trig Functions[三角函数]
    以原点o(0,0)为圆心,做半径为1的单位圆.
    在单位圆上的点坐标为(x,y),作如下定义:
    sinθ = x/1 = x;
    cosθ = y/1 = y;
    tanθ = x/y;
    cscθ = 1/sinθ = 1/x;
    secθ = 1/cosθ = 1/y;
    cotθ = 1/tanθ = y/x;

    由勾股定理,有 x^2 + y^2 = 1 ---> sin^2θ + cos^2θ = 1;
    同理,有 1+tan^2θ = sec^2θ, 1+cot^2θ = csc^2θ;
         
***** Trig Identities[三角恒等式]
     同时,由单位圆几何图像可知,
     sin(-θ) = -x/1 = -x = -sinθ;
     cos(-θ) = y/1 = y = cosθ;
     tan(-θ) = -x/y = -tanθ;

     sin(π/2-θ) = cosθ;
     cos(π/2-θ) = sinθ;
     tan(π/2-θ) = cosθ/sinθ = cotθ;

     由向量点积 a.b = |a| |b| cosθ可得:
     cos(a+b) = cosacosb - sinasinb;
     cos(a-b) = cosacosb + sinasinb;
     sin(a+b) = sinacosb + cosasinb;
     sin(a-b) = sinacosb - cosasinb;
     tan(a+b) = (tana+tanb) / (1 - tanatanb);
     tan(a-b) = (tana -tanb) / (1 + tanatanb);
         
     若 θa = θb,则有:
     (sin2θ) = 2sinθcosθ;
     (cos2θ) = cos^2θ-sin^2θ = 1 - 2sin^2θ = 2cos^2θ - 1;
     (tan2θ) = (2tanθ) / (1 - tan^2θ);

     *law of sines*[sin法则] 和 *law of cosines*[cos法则]
     SinA/a = SinB/b = SinC/c;
     a^2 = b^2 + c^2 - 2bc cosA;
     b^2 = a^2 + c^2 - 2ac cosB;
     c^2 = a^2 + b^2 - 2ab cosC;
** Chapter 2 Vectors[向量]
   vector在数学和物理上具有不同的含义.
   在数学上,vector就是 *数的集合*[list of numbers].
   而在物理上,vector表示 _同时具有大小[magnitude]和方向[direction]的量[quantity]_.

*** 2.1 Mathematical Definition of Vector[向量的数学定义]
    在讨论vector的时候,我们需要明白vector[向量]与 *scalar*[标量]的区别.
    The *dimension*[维度] of a vector tells how many numbers the vector contains.
    vector有几个维度就包括了几个量.
    而scalar可以看成是1维的vector.也就是只包含了单个量的vector.
    至此,我们将引入两个新的概念:
    - *row vector*[行向量]  ---> [1,2,3]
    - *column vector*[列向量] --->  [1]
     [2]
     [3]
*** 2.2 Geometric Definition of Vector [vector的几何定义]
    vector表示 _同时具有大小[magnitude]和方向[direction]的线段[line segment]_.
    vector有 *头*[head] 和 *尾*[tail],头表示 *结束*[ends]的位置,尾表示 *开始*[starts]的位置.
*** 2.3 Vector as a Sequence of Displacements [vector-作为一系列的位移]
    *Displacements*[位移],表示物体的位置变化,定义为 _由初位置到末位置的有向线段_.
    由定义可知,位移是一个vector.
    而在3D向量中,我们通常把向量的位置分解成x,y,z三个位移量.分别表示该向量到三个
    轴的 *有符号距离*[signed distance].
*** 2.4 The Zero Vector [零向量]
    定义:zero vector 是每个维度的值都为0的向量. --> [0,0,0]
    那么零向量到底有什么用?
    我们知道每个向量的值都表示了位移位置的变化,零向量则意味着 _没有发生位移_.
*** 2.5 Vectors VS Points
    *向量*[vector] 表示物体的 *位移*[displacement],
    *点*[points]表示物体的位置.
**** Relative Positions[相对位置]
    所谓 *相对位置*,就是说,一个物体的位置一定是以某个坐标为原点,通过计算原点和物体的距离
    来确定的.
*** 2.6 Unit Vectors [单位向量]
    Unit vector  <-->  normalized vector <--> normals[法线]
    因为有些时候我们只想要知道 _向量的方向_,而不管它的 _大小_,由此就产生了 *Unit Vector*.
    *Unit vector*,就是模为1的矢量.

    而单词 *normal* 通常还有另一层含义: *perpendicular*[正交],表示垂直.
    当我们说 *normal vector* 的时候,其实是在说这个 *vector* 与另外的什么东西垂直.

    When this book refers to a vector as a *normal*, it means _a unit vector perpendicular to_
    _something else_.
    
    最后总结如下,一个 *normalized* vector 总有 *unit length*,但是一个 *normal* vector 表示的是
    一个 1) *垂直*[perpendicular] 于什么东西且 2)通常有 *单位长度*[unit length] 的vector.

    $\hat{v} = \frac{v}{|v|}$
    e.g
    [15 -3] / |[15 -3]| = [15 -3] / sqrt(15^2,-3^2) = [15 -3] / sqrt(225+9) = [15 -3] / sqrt(234)

*** 2.7 Vector Dot Product [向量点积]
    在向量的乘法中,除了 *向量*[vector] 与 *标量*[scalar] 相乘,还有向量与向量的乘法.
    而向量乘法分为两种,一种叫做 *点积*[dot product] , 一种叫做 *叉积*[cross product].
    点积在游戏编程中的使用无处不在,从 *图形学*[graphics] 到 *模拟*[simulation],或者是
    AI,都随处可见.
    
    dot product formula
    $a \cdot b = \sum_{i=1}^n ai$
    
**** Geometric Interpretation[几何解释]
    关于点积有两种几何解释,
    - The dot product a · b is equal to the signed length of the projection of b onto any line 
      parallel to a, multiplied by the length of a.
      点积结果是向量a到另一个向量b的 *投影*[projection]再乘以a的模.
      a . b = projb(a) 乘 |a|
      *投影*,就是指 1)在光线垂直射下来的某个平面的 2)某个物体的 *影子*[shadow].
      也可以说, *投影* 是 _二维到一维的_ *线性变换*[linear transformation].

      *线性*[linear] --> 任意一组 _共线_ 的 _等距离分布_ 的点在变换后依然保持 _共线_
      且 _等距离分布_ , 则说明这个变换是 *线性* 的.

      任何一个从二维到一维的线性变换,其效果等价于 _与向量(a,b)做点乘_,其中a和b为
      两个 *基向量* 被变换到的位置.
       
    - 用三角函数来解释,重点在于vector之间的 *夹角*(angle between the vectors)
      $cos\theta = \frac {\hat{a} \cdot \hat{b}} {1} = \hat{a} \cdot \hat{b}$
      $a \cdot b = |a| |b| cos\theta$
**** Summarize[总结]
    - The dot product a . b measures the length of the projection of b onto a,
      multiplied by the length of a.
    - The dot product can be used to measure displacement in a particular
      dirction.
    - The projection operation is closely related to the cosine function.The dot
      product a . b also is equal to |a| |b| cosθ, where theta is the angle between
      the vectors.
    
*** 2.8 Vector Cross Product [向量叉积]
    向量叉积不同于点积,点积生成一个 *标量*[scalar],而叉积生成一个3D向量同时 _不满足交换律_.
    叉积最重要的作用在于生成一个垂直于平面的向量,生成三角形或者多边形.
**** Geometric Interpretation [几何解释]
    向量的叉积生成一个同时与两个原向量正交[perpendicular]的新向量.
    向量叉积的模:
    $|a \times b| = |a| |b| sin\theta$
    a x b 产生的新向量可能指向两个相反的方向,判断方式如下:
    - 首先,把a的 *头*[head] 和b的 *尾*[tail]相连.
    - 其次,看a到b是顺时针还是逆时针.
    - 1) 如果在左手坐标系中:
      a到b是顺时针,则a x b 生成的新向量会靠近你.
      a到b是逆时针,则a x b 生成的新向量会远离你.
    - 2) 如果在右手坐标系中:
      a到b是顺时针,则a x b 生成的新向量会远离你.
      a到b是逆时针,则a x b 生成的新向量会靠近你.
*** 2.9 Norm of a Vector [范数]
    范数[norm][fn:norm],是具有长度概念的 *函数*.在线性代数等相关数学领域,其含义为 _为向量空间内的_
    _所有向量赋予非0的正常度或者大小._
    范数的本质是 *距离*,它把 _不能比较的向量通过函数来转换为可以比较的实数_.
    1-范数:
    $\vert x \vert_{p} \equiv (\sum_{i=1}^n |x_{i}|^p)^{1/p}$
    
    - $L^1$ norm.(p = 1). --> Taxicab norm (表示向量元素绝对值之和)

     $|x|_{1} \equiv \sum_{i=1}^n |x_{i}|$

    - $L^2$ norm.(p = 2). --> Euclidean norm (计算向量长度)
     
     $|x|_{2} \equiv \sqrt{\sum_{i=1}^n |x_{i^2}|}$

    - The infinity norm.(p = ∞) --> Chebyshev norm (求所有向量元素中最大值)

     $|x|_{∞} \equiv max(|x_{1},...,|x_{n}|)$
** Chapter 3 Multiple Coordinate Spaces[多坐标空间]
   关于多个坐标系统,我们会讨论如下问题:
   1. 为何需要多个坐标系?
   2. 对几个常见坐标系的介绍:
     - world space
     - object space
     - camera space
     - upright space
   3. 坐标系的 *转换*[transformation]
   4. 讨论 *嵌套坐标系*[nested coordinate spaces],主要用于 _3D对象的层级动画(animating 
   hierarchically segmented objects in 3D space)_

*** 3.1 Why bother with Multiple Coordinate Spaces?[为什么要使用多个坐标系?]
    从直觉上来说,我们把所有的东西放在一个坐标系里,记录每个东西的位置,是理所当然的做法.
    通常我们把这个坐标系叫做 *世界坐标系*[world coordinate space].
    但是考虑一个问题,当我们把一个物体置入世界坐标系的时候,到底怎么样才能清晰直观的表现
    它的位置,方向等信息?
    同样显而易见的是,我们以物体自身为坐标系,来表示它的 *位置*[position], *旋转*[rotation] 和
    *大小*[scale],符合我们的直觉的同时也更简单.
    而在这种情况下,最理想的办法无疑是让自身的坐标系和世界坐标系并存,让物体从自身坐标系转换
    到世界坐标系.
*** 3.2 Some Useful Coordinate Spaces
**** World Space
    世界坐标系是用来表示 *绝对位置*[absolute position] 的,在游戏中, 意味着它表示的是在游
    戏范围内最大的坐标空间.
    同样, *世界坐标系*[world coordinate space] 也被叫做 *全球*[global] 或者 *通用*[universal]
    坐标系.
**** Object Space
    *对象空间* 是指依附于某个具体对象的 *坐标空间*[cordinate space].
    同样的, *对象空间* 也被叫做 *model space* 或者是 *body space*.
    这里有个有趣的例子[fn:worldspace].
**** Camera Space
    首先要明白,Camera Space 是 1. _带有 *视点*[viewpoint]_ 2. _用于渲染的_ Object Space.
    在Camera Space中(Left-handed conventions),
    - +x --> *right*
    - +y --> *up*
    - +z --> *forward*
    需要区别的在于 *Camera Space* (是一个3D Space), *Screen Space*(是一个2D Space).
    为了让 Camera Space 映射到 Screen Space,我们需要用的一个技巧是 *投影*[projection].
**** Upright Space
    Upright Space 是什么意思?它表示的是 *World Space*  <---> *Object Space* 的 *中间状态*.
    就是说,
    - Upright Space 的轴分别 *平行*[parallel] 于 World Space 的轴.
    - Upright Space 的坐标原点与 *Object Space* 的坐标原点一致.

    为什么需要Upright Space?
    仔细想想,在世界坐标系中的物体的所有位置,都可以通过对该物体 *平移*[translation] 和
    *旋转*[rotation] 得到.
*** 3.3 Basis Vectors and Coordinate Space[基向量与坐标空间]
    在实际的游戏编程中,我们常常会遇到一个问题:我知道某个物体在当前坐标的具体位置,但是
    它在另一个坐标系中应该如何表示?
    这个过程被叫做 *coordinate space translation*[坐标空间转换].
**** Dual Perspectives[双重视角]
    我们已经知道,在世界坐标系中的物体的位置都可通过物体的平移与旋转得到.而在实际考虑
    问题的时候,我们的具体步骤是:
    1. 旋转
    2. 平移
    为什么要先旋转再平移?原因在于围绕 *原点* 进行旋转是 *线性变换*[linear transform],而围绕
    其他点旋转则是在进行 *仿射变换*[affine transformation],仿射变换要麻烦的多.
    如果我们要先平移再旋转,就需要进行如下步骤:
    1. 将旋转中心平移到原点
    2. 以原点为中心旋转到指定角度
    3. 平移
    而最终,为了能渲染出摄像机视野内的物体,我们需要将目标模型变换到 *Camera Space*.但是就算
    是转换到了 *Camera Space*,故事也还没有结束,我们还需要将顶点转换到 *Clip Space*,最后 *投影* 
    到 *Screen Space*.
    整个流程大概是:
    Object Space --> World Space --> Camera Space --> Clip Space --> Screen Space
    其中,World Space 到 Camera Space 则通过 *顶点着色器*[vertex shader] 完成.
    *active transformation*
    *passive transformation*
    active和passive都用来表示Object的状态,active表示移动Object,passive表示让Object静止,移动坐
    标系.
**** Specifying Coordinate Spaces[指定坐标空间]
    通过描述 *原点*[origin] 和 *轴*[axis],就能指定一个坐标空间.
    *原点* 是一个用来 _定义空间位置的点_,而 *轴* 则是用来 _描述空间方向的向量_.
    我们定义的原点是相对于 *父坐标空间*[parent coordinate space]而言的,因为在 *子空间*[child space]
    中,原点总被表示为(0,0,0).
**** Basis Vectors[基向量]
    $\vec{v} = x\vec{p}+y\vec{q}+z\vec{r}$
    其中,$\vec{p}=[1,0,0] \vec{q}=[0,1,0],\vec{r}=[0,0,1]$,也就是所谓的基向量.


    如何将本地坐标系中的位置转换到世界坐标系?
    1. 找到本地坐标系的原点,将 _原点以世界坐标系的位置_ 表示.
    2. 以upright坐标系的 *单位向量*[unit vector]为基础,分别将本地坐标系的单位向量(+x +y)在upright
    坐标系中表示.
    3. 
    原点位置
    + 根据向量在本地坐标系中的位置的标量值,分别乘以upright坐标系中表示的 _本地坐标系的单位向量_
    = 该本地向量在世界坐标系中的位置
    公式为:
    $\vec{w} = \vec{o} + b_{x}\vec{p} + b_{y}\vec{q}$
    以基向量的 *线性组合*[linear combination]的方式表示一个3D向量:
    $\vec{v} = x\vec{p} + y\vec{q} + z\vec{r}$
    
    在理想状况下,我们希望基向量都互相垂直并且具有相同的大小,然而现实往往并不能如愿.
    我们举以下几个例子来说明下非理想状况下的基向量的应用:

    1. _Scale an Object_
    当我们对一个物体进行缩放的时候,考虑到不是同时对x,y,z轴都进行缩放,所以往往缩放后的结果是原
    物体的基向量不再垂直或者具有相同的长度.

    2. _Texture Mapping/Bump Mapping_
    在 *表面*[surface]上建立一个轴(+z)平行于 *表面法线*[fn:surfacenormal]的本地坐标系通常会很有用.
    而另外的两个轴 u 和 v 分别被叫做 *切线* [tangent] 和 *次法线*[binormal],在2D纹理中,分别沿 *水平*
    和 *垂直* 方向延伸.
    通常在 *平面2D纹理*[flat 2D texture]中,通常会将纹理贴在不规则的表面上,并且基向量往往不能保证
    是互相垂直的.

    之所以基向量不必非要互相垂直,是因为在一个平面上,只要 _两个不平行的基向量_ 就能描述平面内的任意
    向量,也即是说,在同一平面内的任意两个不平行的基向量即可构成一个平面.
    这些由基向量线性变换得来的向量的集合被叫做 _the *span* of the basis_.由此可推:
    2 basis vectors --> the span is an infinite 2D plane.
    3 basis vectors --> the span is an infinite 3D plane.
    *linear span* --> 线性生成空间
    *rank* -->
    _秩,由基向量张成的空间的维度数量被叫做秩._
    the number of dimensions in the space _spanned by the basis_ is the *rank* of the basis.
    *linear dependent* --> 线性相关
    *linear independent* --> 线性无关 --> *满秩*[full rank]

    _如何判断一组向量是否线性相关?_
    $a_{1}\vec{v}_{1} + a_{2}\vec{v}_{2} +  ... a_{n}\vec{v}_{n} = 0$
    即:
    $\sum_{i=1}^n a_{i}\vec{v}_{i} = 0$
    若等式成立,则这组向量是线性相关的.

    A set of basis vectors that are _mutually perpendicular_ is called an *orthogonal basis*.
    一组互相垂直的基向量被叫做 *正交基*.
    *orthonormal basis*[标准正交基],在正交基的基础上还具有 *单位长度*[unit length].
*** 3.4 Nested Coordinate Spaces[嵌套坐标空间]
    *Articulated model*[关节模型] --> 由嵌套坐标空间构成的模型.
    在物体的动画系统中,使用嵌套坐标空间能简单高效的描述各个部分的运动关系.
*** 3.5 In Defense of Upright Space[再次为upright space站台]
    在程序代码里,一个数据类型如 *float3*,往往具有两个含义:
    1. 作为一个 *vector*
    2. 作为一个 *point*
    永远要记住,一个 *vector* 表示的是 _一段位移(同时具有大小和方向)_,而一个 *Point* 表示的是
    *位置*[Position].
** Chapter 4 Introduction to Matrices[矩阵导论]
   *矩阵*[Matrices],主要用来描述两个坐标空间之间的关系.它计算从一个坐标空间到另一个坐标
   空间的 _向量变换_ .
*** 4.1 Mathematical Definition of Matrix[矩阵的数学定义]
    A vector is an _array of scalars_,and a matrix is an _array of vectors_.
**** Matrix Dimensions and Notation[矩阵行列和符号]
    \begin{bmatrix}
             4 & 0 & 12\\
             -5 & \Sqrt{4} & 3\\
             12 & -4/3 & -1\\
             1/2 & 18 & 0 \\
    \end{bmatrix}
    这是一个 4(row)x3(col)矩阵.表示矩阵由4 *行*[row] 3 *列*[column]组成.
    \begin{bmatrix}
             m_{11} & m_{12} & m_{13}\\
             m_{21} & m_{22} & m_{23}\\
             m_{31} & m_{32} & m_{33}\\
    \end{bmatrix}
    符号 $m_{ij}$ 表示在M中i行j列的元素的值.需要注意的是在很多编程语言中,数组下标是从0开始的,而矩阵下
    标则是从1开始的.在编程的时候使用矩阵时,一定要注意区别.
**** Square Matrices[方阵]
    *方阵*[square matrices]就是 _行和列相等_ 的矩阵.
    *对角元素*[diagonal elements] 就是指 _行和列的下标相同_ 的 *方阵* 中的元素.
    如下:
    \begin{bmatrix}
             \boldsymbol{m_{11}} & m_{12} & m_{13}\\
             m_{21} & \boldsymbol{m_{22}} & m_{23}\\
             m_{31} & m_{32} & \boldsymbol{m_{33}}\\
    \end{bmatrix}

    *对角矩阵*[diagonal matrix] 就是指 *非对角元素* 为0的矩阵.
    如下:
    \begin{bmatrix}
             \boldsymbol{m_{11}} & 0 & 0\\
             0 & \boldsymbol{m_{22}} & 0\\
             0 & 0 & \boldsymbol{m_{33}}\\
    \end{bmatrix}
    *单位矩阵*[identity matrix] 就是指对角元素都为1的 *对角矩阵*.
    如下:
    \begin{equation}
    \boldsymbol{I_{3}} =
    \begin{bmatrix}
             \boldsymbol{1} & 0 & 0\\
             0 & \boldsymbol{1} & 0\\
             0 & 0 & \boldsymbol{1}\\
    \end{bmatrix}
    \end{equation}
    单位矩阵的特殊之处在于它是乘法恒等式.如果你让一个矩阵与单位矩阵做乘法,得到的是原矩阵.
    单位矩阵之于矩阵,就如同数字1之于标量.
**** Vectors as Matrices[向量作标量]
    矩阵通常由n行n列组成(n>=1),而一个 *向量*[vector]可以被看成是 *一行*[$1 \times n$] 或者是 *一列*[$n \times 1$]
    的矩阵.
    *行向量*[row vector] --> $1 \times n$ 矩阵
    e.g
    \begin{bmatrix}
    1 & 2 & 3
    \end{bmatrix}
    *列向量*[column vector] --> $n \times 1$ 矩阵
    e.g
    \begin{bmatrix}
    1 \\
    2 \\
    3
    \end{bmatrix}
**** Matrix Transposition[转置矩阵]
    假设有一个矩阵$\boldsymbol{M} (r \times c)$,则它的 *转置*[transpose] 矩阵为
    $\boldsymbol{M^T} (c \times r)$,有$\boldsymbol{M^T_{ij}} = \boldsymbol{M_{ji}}$.
    e.g
    \begin{equation}
    \begin{bmatrix}
             1 & 2 & 3\\
             4 & 5 & 6\\
             7 & 8 & 9\\
             10 & 11 & 12\\
    \end{bmatrix}
    ^T =
    \begin{bmatrix}
             1 & 4 & 7 & 10\\
             2 & 5 & 8 & 11\\
             3 & 6 & 9 & 12\\
    \end{bmatrix}
    \end{equation}

    \begin{equation}
    \begin{bmatrix}
             a & b & c\\
             d & e & f\\
             g & h & i\\
    \end{bmatrix}
    ^T =
    \begin{bmatrix}
             a & d & g\\
             b & e & h\\
             c & f & i\\
    \end{bmatrix}
    \end{equation}

    \begin{equation}
    \begin{bmatrix}
             x & y & z\\
    \end{bmatrix}
    ^T =
    \begin{bmatrix}
             x\\
             y\\
             z\\
    \end{bmatrix}
    \end{equation}
    如下,有两个结论:
    $(\boldsymbol{M}^T)^T = \boldsymbol{M}$
    $\boldsymbol{D^T} = \boldsymbol{D} , D = (Diagonal Matrix)$
**** Multiply a Matrix with Scalar[矩阵的标量乘法]
    与向量的标量乘法相同:
    \begin{equation}
    k \boldsymbol{M} = k
    \begin{bmatrix}
    m_{11} & m_{12} & m_{13} \\
    m_{21} & m_{22} & m_{23} \\
    m_{31} & m_{32} & m_{33} \\
    m_{41} & m_{42} & m_{43} \\
    \end{bmatrix} 
    =
    \begin{bmatrix}
    km_{11} & km_{12} & km_{13} \\
    km_{21} & km_{22} & km_{23} \\
    km_{31} & km_{32} & km_{33} \\
    km_{41} & km_{42} & km_{43} \\
    \end{bmatrix} 
    \end{equation}
**** Multiplying Two Matrix[矩阵乘法]
    $\boldsymbol{A} (r \times n) , \boldsymbol{B} (n \times c) , \boldsymbol{AB} (n \times c)$
    矩阵乘法中,第一个矩阵的列数必须与第二个矩阵的行数相等才能进行.
    同时,矩阵乘法不满足交换律.
    公式如下:
    $c_{ij} = \sum_{k=1}^n a_{ik}b_{kj}$
    第一个矩阵的行向量与第二个矩阵的列向量做 *点乘*.
    e.g
    \begin{equation}
    \boldsymbol{AB} =
    \begin{bmatrix}
    a_{11} & a_{12} \\
    a_{21} & a_{22}
    \end{bmatrix}
    \begin{bmatrix}
    b_{11} & b_{12} \\
    b_{21} & b_{22}
    \end{bmatrix}
    =
    \begin{bmatrix}
    a_{11}b_{11} + a_{12}b_{21} & a_{11}b_{12} + a_{12}b_{22} \\
    a_{21}b_{11} + a_{22}b_{21} & a_{21}b_{12} + a_{22}b_{22} \\
    \end{bmatrix}
    \end{equation}

    \begin{equation*}
    \begin{flushleft}
    \boldsymbol{A} =
    \begin{bmatrix}
    -3 & 0 \\
    5 & 1/2
    \end{bmatrix},
    \boldsymbol{B} =
    \begin{bmatrix}
    -7 & 2 \\
    4 & 6 
    \end{bmatrix},
    \\
    \boldsymbol{AB} =
    \begin{bmatrix}
    (-3)(-7) + (0)(4) & (-3)(2) + (0)(6) \\
    (5)(-7) + (1/2)(4) & (5)(2) + (1/2)(6)\\
    \end{bmatrix}
    =
    \begin{bmatrix}
    21 & -6 \\
    -33 & 13 
    \end{bmatrix}
    \end{flushleft}
    \end{equation*}
    下面是矩阵乘法的一些特点:
    - M与方阵相乘,得到的矩阵大小和原矩阵相同.而M与单位矩阵相乘,结果是M自身.
      $\boldsymbol{MI} = \boldsymbol{IM} = \boldsymbol{M}$

    - 矩阵乘法不满足交换律
      $\boldsymbol{AB} \neq  \boldsymbol{BA}$

    - 矩阵乘法满足结合律
      $\boldsymbol{(AB)C} = \boldsymbol{A(BC)}$

    - 标量(或向量)与矩阵相乘满足结合律
      $\boldsymbol{(kA)B} = \boldsymbol{k(AB)}$
      $\boldsymbol{(\vec{v}A)B} = \boldsymbol{\vec{v}(AB)}$

    - 矩阵乘法的转置
      $\boldsymbol{(AB)^T} = \boldsymbol{B^TA^T}$
**** Multiplying a Vector and a Matrix[矩阵与向量相乘]
    首先要注意的是,向量与矩阵相乘或者矩阵与向量相乘的前提是,第一个参数的 *列* 必须要与第二个参数
    的 *行* 一致,否则不能进行乘法运算.
    \begin{equation*}
    \begin{flushleft}
    \begin{bmatrix}
    x & y & z
    \end{bmatrix}
    \begin{bmatrix}
    m_{11} & m_{12} & m_{13} \\
    m_{21} & m_{22} & m_{23} \\
    m_{31} & m_{32} & m_{33} \\
    \end{bmatrix}
    =
    \\
    \begin{bmatrix}
    xm_{11}+ym_{21}+zm_{31} & xm_{12}+ym_{22}+zm{32} & xm_{13}+ym_{23}+zm_{33}
    \end{bmatrix}
    \end{flushleft}
    \end{equation*}

    \begin{equation*}
    \begin{flushleft}
    \begin{bmatrix}
    m_{11} & m_{12} & m_{13} \\
    m_{21} & m_{22} & m_{23} \\
    m_{31} & m_{32} & m_{33} \\
    \end{bmatrix}
    \begin{bmatrix}
    x \\
    y \\ z
    \end{bmatrix}
    =
    \\
    \begin{bmatrix}
    xm_{11}+ym_{12}+zm_{13} & xm_{21}+ym_{22}+zm{23} & xm_{31}+ym_{32}+zm_{33}
    \end{bmatrix}
    \end{flushleft}
    \end{equation*}

    向量与矩阵相乘满足分配律:
    e.g
    $(\vec{v}+\vec{w})\boldsymbol{M} = \vec{v}\boldsymbol{M} + \vec{w}\boldsymbol{M}$
    Finally, and perhaps most important at all,the result of the multiplication is a _linear combination_
    _of the rows or columns of the matrix_.
**** Row versus Column Vectors[行向量和列向量]
    \begin{equation*}
    \begin{flushleft}
    \begin{bmatrix}
    x & y & z
    \end{bmatrix}
    \begin{bmatrix}
    m_{11} & m_{12} & m_{13} \\
    m_{21} & m_{22} & m_{23} \\
    m_{31} & m_{32} & m_{33} \\
    \end{bmatrix}
    =
    \\
    \begin{bmatrix}
    xm_{11}+ym_{21}+zm_{31} & xm_{12}+ym_{22}+zm{32} & xm_{13}+ym_{23}+zm_{33}
    \end{bmatrix}
    \end{flushleft}
    \end{equation*}

    \begin{equation*}
    \begin{flushleft}
    \begin{bmatrix}
    m_{11} & m_{12} & m_{13} \\
    m_{21} & m_{22} & m_{23} \\
    m_{31} & m_{32} & m_{33} \\
    \end{bmatrix}
    \begin{bmatrix}
    x \\
    y \\ z
    \end{bmatrix}
    =
    \\
    \begin{bmatrix}
    xm_{11}+ym_{12}+zm_{13} & xm_{21}+ym_{22}+zm{23} & xm_{31}+ym_{32}+zm_{33}
    \end{bmatrix}
    \end{flushleft}
    \end{equation*}

    从上面的矩阵与相同元素的行/列向量相乘我们可以发现,相乘的结果是不同的.
    先解释一下为什么会有这种区别,再给出建议使用 *行向量*[row vector]给出一些理由.
    - *行向量* 是 _从左到右_ 的顺序读写的.特别是在进行多个变换的时候. 
      *列向量* 却必须 _从右到左_.
      e.g
      $\vec{v} \boldsymbol{ABC}$ (row vector)
      $\boldsymbol{CBA} \vec{v}$ (col vector)

    - 尽管在实际生活中,使用列向量会让矩阵看起来更直观(特别是在维数增加的时候),但是在游戏编程里,
    代码的可读性往往比公式的可读性更重要.

    在许多API里,DirectX使用的是行向量,而OpenGL使用的则是列向量,在实际编程中要注意区分.
*** 4.2 Geometric Interpretation of Matrix[矩阵的几何解释]
    不管怎么样,一个 *方阵*[square matrix] 可以描述 _任何矩阵变换_.
    一个 *线性变换* 可以 *伸展*[stretch] 坐标空间,但是却不能 *弯曲*[warp] 它.
    常见的线性变换包括:
    - *rotation*[旋转]
    - *scale*[缩放]
    - *orthographic projection*[正交投影]
    - *shearing*[裁剪]
    - *reflection*[反射]

    已知 *基向量*[basis vectors] $\vec{i} = [1,0,0],\vec{j} = [0,1,0], \vec{k} = [0,0,1]$,与任意矩阵$\boldsymbol{M}$
    相乘结果如下:
    \begin{equation*}
    \boldsymbol{\vec{i}M} =
    \begin{bmatrix}
    1 & 0 & 0
    \end{bmatrix}
    \begin{bmatrix}
    m_{11} & m_{12} & m_{13} \\
    m_{21} & m_{22} & m_{23} \\
    m_{31} & m_{32} & m_{33} \\
    \end{bmatrix}
    =
    \begin{bmatrix}
    m_{11} & m_{12} & m_{13}
    \end{bmatrix}
    \end{equation*}

    \begin{equation*}
   \boldsymbol{\vec{i}M} =
   \begin{bmatrix}
   0 & 1 & 0
   \end{bmatrix}
   \begin{bmatrix}
   m_{11} & m_{12} & m_{13} \\
   m_{21} & m_{22} & m_{23} \\
   m_{31} & m_{32} & m_{33} \\
   \end{bmatrix}
   =
   \begin{bmatrix}
   m_{21} & m_{22} & m_{23}
   \end{bmatrix}
   \end{equation*}

    \begin{equation*}
   \boldsymbol{\vec{i}M} =
   \begin{bmatrix}
   0 & 0 & 1
   \end{bmatrix}
   \begin{bmatrix}
   m_{11} & m_{12} & m_{13} \\
   m_{21} & m_{22} & m_{23} \\
   m_{31} & m_{32} & m_{33} \\
   \end{bmatrix}
   =
   \begin{bmatrix}
   m_{31} & m_{32} & m_{33}
   \end{bmatrix}
   \end{equation*}

    而我们之前已经知道任何向量都可以表示成基向量的 *线性组合*[linear combination],
    $\boldsymbol{\vec{v}} = v_{x} \boldsymbol{\vec{i}} + v_{y} \boldsymbol{\vec{j}} + v_{z} \boldsymbol{\vec{k}}$
    则向量与矩阵相乘可表示为:
    \begin{equation*}
    \begin{flushleft}
    \boldsymbol{\vec{v}M} = 
    (v_{x} \boldsymbol{\vec{i}} + v_{y} \boldsymbol{\vec{j}} + v_{z} \boldsymbol{\vec{k}}) \boldsymbol{M}
    \\=
    (v_{x} \boldsymbol{\vec{i}})\boldsymbol{M} + 
    (v_{y} \boldsymbol{\vec{j}})\boldsymbol{M} + 
    (v_{z} \boldsymbol{\vec{k}})\boldsymbol{M})
    \\=
    v_{x} (\boldsymbol{\vec{i}} \boldsymbol{M}) + 
    v_{y} (\boldsymbol{\vec{j}} \boldsymbol{M}) + 
    v_{z} (\boldsymbol{\vec{k}} \boldsymbol{M}))
    \\=
    v_{x}
    \begin{bmatrix}
    m_{11} & m_{12} & m_{13}
    \end{bmatrix}
    +v_{y}
    \begin{bmatrix}
    m_{21} & m_{22} & m_{23}
    \end{bmatrix}
    +v_{z}
    \begin{bmatrix}
    m_{31} & m_{32} & m_{33}
    \end{bmatrix}
    \end{flushleft}
    \end{equation*}
    等价于:
    \begin{equation*}
    \begin{flushleft}
    \boldsymbol{\vec{v}M} = 
    \begin{bmatrix}
    v_{x} & v_{y} & v_{z}
    \end{bmatrix}
    \begin{bmatrix}
    \boldsymbol{-p-}\\
    \boldsymbol{-q-}\\
    \boldsymbol{-r-}\\
    \end{bmatrix}
    =
    v_{x} \boldsymbol{\vec{p}} + v_{y} \boldsymbol{\vec{q}} + v_{z} \boldsymbol{\vec{r}}
    \end{flushleft}
    \end{equation*}

    从上可知,矩阵的行其实可以看成是 _该坐标空间的基向量[basis vectors]_.
    e.g
    \begin{equation*}
    \boldsymbol{M}=
    \begin{bmatrix}
    2 & 3 \\
    1 & 2
    \end{bmatrix}
    \end{equation*}
    在这里,可以看成是,基向量$\boldsymbol{p} = [2 , 3], \boldsymbol{q} = [1 , 2]$.
    把n维矩阵看成是n个基向量的集合,那么向量与矩阵的乘法,就可以看成是 _对每个矩阵中的基向量做线性_
    _组合_
    *总结*

    - The rows of a *square matrix* can be interpreted as the basis vectors of a coordinate space.
     方阵的行可以看成是坐标空间中的基向量.

    - To transform a vector from original coordinate space to the new coordinate space,we multiply
     the vector by matrix.
     向量与矩阵相乘的几何意义是:把向量从原坐标空间转换到新的坐标空间.

    - The transformation from the original coordinate space to the coordinate space defined by these
    basis vectors is a linear transformation. A linear transformation preserves straight lines,and parallel
    lines remain parallel. However, angles, lengths, areas, and volumes may be altered after transfor-
    mation.
    由基向量定义的从原始坐标空间到新的坐标空间的转换是一个线性变换.线性变换的时候直线和平行线仍
    然保持平行.但是,角度,长度,面积,体积等都会受变换影响改变.

    - Multiplying the zero vector by any square matrix results in the zero vector.Therefor, the linear trans-
    formation represented by a square matrix has the same origin as the original coordinate space -->
    the transformation does not contain translation.
    方阵与零向量相乘只会得到一个零向量.对方阵做线性变换不会改变原点坐标--> _变换不包括平移_.

    - We can visualize a matrix by visualizing the basis vector of the coordinate space after transfor-
    mation.These basis vectors form an 'L' in 2D,and a tripod in 3D.Using a box or auxiliary object also
    helps in visualiation.
    通过把矩阵的行当作基向量,我们可以把矩阵形象化.在2D中,基向量呈L型,在3D中就像一个三脚架.
*** 4.3 The Bigger Picture of Linear Algebra[关于更多:线性代数]
    线性代数是用来操作和求解线性方程的.在游戏中,求解线性方程组最频繁的是 *物理引擎*[physics 
    engine].另外一些常见的应用是 *最小二乘方法*[least squares approximation] 和 *数据拟合*[data fitting].
    虽然传统的线性代数和方程组在基础的游戏编程中不是必须的,但是在很多高级领域,它们确是必不可少的,
    来看下现在的某些技术:
    *fluid*[流体], *cloth*[布料], *hair simulation(and rendering)*[头发模拟(和渲染)],
    *procedural animation of characters*[角色程序动画], *real-time global illumination*[实施全局光照],
    *machine vision*[机器视觉], *gesture recognition*[手势识别] ...
    都需要用到线性代数.
** Chapter 5 Matrices and Linear Transformations[矩阵和线性变换]
   *仿射变换*[affline transformation] = *线性变换*[linear transformation] + *平移*[displacement]
*** 5.1 Rotation[旋转]
**** Rotation in 2D[2D下的旋转]
    在2D坐标中,只有一种可能的旋转 -- 围绕 *点*[point]旋转.
    2D下的旋转公式如下:
    \begin{equation*}
    \boldsymbol{R}(\theta) =
    \begin{bmatrix}
    -\boldsymbol{p'}- \\
    -\boldsymbol{q'}- \\
    \end{bmatrix}
    =
     \begin{bmatrix}
     cos\theta & sin\theta \\
     -sin\theta & cos\theta
    \end{bmatrix}
    \end{equation*}
**** 3D Rotation about Cardinal Axes[围绕主轴的3D旋转]
    在3D场景下,围绕 *轴*[axis] 的旋转比围绕点的旋转更为普遍.
    3D场景下绕坐标轴旋转的公式如下:
    围绕x轴旋转:
    \begin{equation*}
    \boldsymbol{R}_{x}(\theta) =
    \begin{bmatrix}
    -\boldsymbol{p'}- \\
    -\boldsymbol{q'}- \\
    -\boldsymbol{r'}- \\
    \end{bmatrix}
    =
    \begin{bmatrix}
    1 & 0 & 0 \\
    0 & cos\theta &sin\theta \\
    0 & -sin\theta & cos\theta
    \end{bmatrix}
    \end{equation*}
    围绕y轴旋转:
    \begin{equation*}
    \boldsymbol{R}_{y}(\theta) =
    \begin{bmatrix}
    -\boldsymbol{p'}- \\
    -\boldsymbol{q'}- \\
    -\boldsymbol{r'}- \\
    \end{bmatrix}
    =
    \begin{bmatrix}
    cos\theta & 0 & -sin\theta \\
    0 & 1 & 0 \\
    sin\theta & 0 & cos\theta & \\
    \end{bmatrix}
    \end{equation*}
    围绕z轴旋转:
    \begin{equation*}
    \boldsymbol{R}_{z}(\theta) =
    \begin{bmatrix}
    -\boldsymbol{p'}- \\
    -\boldsymbol{q'}- \\
    -\boldsymbol{r'}- \\
    \end{bmatrix}
    =
    \begin{bmatrix}
    cos\theta & sin\theta & 0\\
    -sin\theta & cos\theta & 0 \\
    0 & 0 & 1\\
    \end{bmatrix}
    \end{equation*}
**** 3D Rotation about an Arbitrary Axis[围绕任意轴的3D旋转]
    在不考虑位移的情况下,现在我们讨论如何围绕任意轴做旋转.
    首先,定义围绕任意轴旋转的角度为$\theta$,而该轴则由单位向量 $\hat{n}$ 来定义.
    $\boldsymbol{v'} = \boldsymbol{vR}(\hat{n},\theta)$
    其中,$\boldsymbol{v'}$ 表示围绕单位向量$\hat{n}$ 旋转角度$\theta$ 后的值.
    在实现矩阵之前,我们先来看看能不能把$v'$ 用$\vec{v}$,$\hat{n}$ 和 $\theta$ 描述出来.
    1. 首先,一个向量总是可以看成是多段基向量相加组成,
       $\vec{v} = x\hat{p} + y\hat{q} + z\hat{r}$
    2. 同样,一个向量可以表示成
       $\vec{v} = \vec{v}_{||} + \vec{v}_{\perp}$,其中$\vec{v}_{||}$ 可以表示为向量在某一向量上的投影
    3. 由此,有
       $\vec{v} = \vec{v}_{||} + \vec{v}_{\perp} = proj(\vec{v},\hat{n}) + \vec{v}_{\perp}$
       $\vec{v'}= \vec{v'}_{||} + \vec{v'}_{\perp} = proj(\vec{v'},\hat{n'}) + \vec{v'}_{\perp}$
    4. 其中有 $\vec{v}_{||} = \vec{v'}_{||}$ ,所以问题被化简为求向量 $\vec{v'}_{\perp}$ .
    5. $\vec{v}_{\perp}$ 绕轴旋转$\theta$ 得到 $\vec{v'}_{\perp}$,根据此条件来求出$\vec{v'}_{\perp}$ .
    6. $\hat{n}$ 和 $\vec{v}_{\perp}$ 的叉积可以得到一个分别垂直于它们的向量 $\vec{w}$ ,而显而易见的是,
       $\vec{v}_{\perp}$ , $\vec{v'}_{\perp}$  和 $\vec{w}$ 同处一个平面内,同时 $\vec{v}_{\perp}$ (作x轴) 和 $\vec{w}$ (作y轴)还构成了一个正交的2D坐标空间.
       由此,我们就可以在正交的2D坐标空间内通过坐标轴旋转来得到向量 $\vec{v'}_{\perp}$.可得出
       $\vec{v'}_{\perp} = cos\theta \vec{v}_{\perp} + sin\theta \vec{w}$

    综上,各向量可表示为:
    $\vec{v}_{||} = (\vec{v} \cdot \hat{n})\hat{n}$
    $\vec{v}_{\perp} = \vec{v} - \vec{v}_{||} = \vec{v} - (\vec{v} \cdot \hat{n})\hat{n}$
    $\vec{w} = \hat{n} \times \vec{v}_{\prep} = \hat{n} \times (\vec{v} - \vec{v}_{||}) = \hat{n} \times \vec{v} - 0 = \hat{n} \times \vec{v}$
    $\vec{v'}_{\perp} = cos\theta\vec{v}_{\perp} + sin\theta\vec{w} = cos\theta(\vec{v}-(\vec{v} \cdot \hat{n})\hat{n}) + sin\theta(\hat{n} \times \vec{v}))$
    $\vec{v'} = \vec{v'}_{\perp} + \vec{v'}_{||} = cos\theta(\vec{v}-(\vec{v} \cdot \hat{n})\hat{n}) + sin\theta(\hat{n} \times \vec{v}) + (\vec{v} \cdot \hat{n})\hat{n}$
    
    \begin{equation*}
    p =
    \begin{bmatrix}
    1 & 0 & 0 \\
    \end{bmatrix},
    p' =
    \begin{bmatrix}
    n_{x^2}(1-cos\theta) + cos\theta \\
    n_{x}n_{y}(1-cos\theta) + n_{z}sin\theta \\
    n_{x}n_{z}(1-cos\theta) - n_{y}sin\theta
    \end{bmatrix}^T
    \end{equation*}

    \begin{equation*}
    q =
    \begin{bmatrix}
    0 & 1 & 0 \\
    \end{bmatrix},
    q' =
    \begin{bmatrix}
    n_{x}n_{y}(1-cos\theta) - n_{z}sin\theta \\
    n_{y^2}(1-cos\theta) + cos\theta \\
    n_{y}n_{z}(1-cos\theta) + n_{x}sin\theta
    \end{bmatrix}^T
    \end{equation*}

    \begin{equation*}
    r =
    \begin{bmatrix}
    0 & 0 & 1 \\
    \end{bmatrix},
    r' =
    \begin{bmatrix}
    n_{x}n_{z}(1-cos\theta) + n_{y}sin\theta \\
    n_{y}n_{z}(1-cos\theta) - n_{x}sin\theta \\
    n_{z^2}(1-cos\theta) + cos\theta \\
    \end{bmatrix}^T
    \end{equation*}

    \begin{equation*}
    \boldsymbol{R(\hat{n},\theta)} =
    \begin{bmatrix}
    -p'- \\
    -q'- \\
    -r'- \\
    \end{bmatrix} =
    \begin{bmatrix}
    n_{x^2}(1-cos\theta) + cos\theta & n_{x}n_{y}(1-cos\theta) + n_{z}sin\theta & n_{x}n_{z}(1-cos\theta) - n_{y}sin\theta \\
    n_{x}n_{y}(1-cos\theta) - n_{z}sin\theta & n_{y^2}(1-cos\theta) + cos\theta & n_{y}n_{z}(1-cos\theta) + n_{x}sin\theta \\
    n_{x}n_{z}(1-cos\theta) + n_{y}sin\theta & n_{y}n_{z}(1-cos\theta) - n_{x}sin\theta & n_{z^2}(1-cos\theta) + cos\theta
    \end{bmatrix}
    \end{equation*}
*** 5.2 Scale[缩放]
    在缩放的时候,我们往往会考虑两种缩放的情况.
    一种是 *Uniform Scale*,即表示对整个物体以原点为中心,全体等比例缩放.
    如果缩放比例为k的话,则缩放长度为k,缩放面积为k^2,缩放体积为k^3.

    一种是 *None-uniform Scale*,即表示可以让物体沿各个方向缩放.
    由于缩放的大小取决于缩放方向,所以k的大小会造成不同的影响:
    $|k| <1$ -> 物体在该方向上会变得更短,$|k| > 1$ -> 物体在该方向上会变得更长.
    $k = 0$ -> 物体 *投影*[projection] 在该方向上, $k < 0$  -> 造成物体的 *反射*[reflection].
**** Scaling along the Cardinal Axes[以主轴缩放]
    先考虑2D的情况,其实在2D的情况下很简单,我们只需要将基向量乘以k就行了.
    \begin{equation*}
    \boldsymbol{p'} = k_{x} \boldsymbol{p} = k_{x}
    \begin{bmatrix}
    1 & 0 \\
    \end{bmatrix}
    =
    \begin{bmatrix}
    k_{x} & 0 \\
    \end{bmatrix}
    ,
    \boldsymbol{q'} = k_{y} \boldsymbol{q} = k_{y}
    \begin{bmatrix}
    0 & 1 \\
    \end{bmatrix}
    =
    \begin{bmatrix}
    0 & k_{y} \\
    \end{bmatrix}.
    \end{equation*}
    由此可得Matrix $S(k_{x},k_{y})$ :

    \begin{equation*}
    \boldsymbol{S}(k_{x},k_{y}) =
    \begin{bmatrix}
    \boldsymbol{-p'-} \\
    \boldsymbol{-q'-}
    \end{bmatrix} =
    \begin{bmatrix}
    k_{x} & 0\\
    0 & k_{y}
    \end{bmatrix}
    \end{equation*}

    在3D中,表达也很简单,由2D可推:

    \begin{equation*}
    \boldsymbol{S}(k_{x},k_{y},k_{z}) =
    \begin{bmatrix}
    \boldsymbol{-p'-} \\
    \boldsymbol{-q'-} \\
    \boldsymbol{-r'-}
    \end{bmatrix} =
    \begin{bmatrix}
    k_{x} & 0 & 0\\
    0 & k_{y} & 0 \\
    0 & 0 & k_{z} 
    \end{bmatrix}
    \end{equation*}

    如果要让矩阵与任意的向量相乘,结果就是把向量的每个部分分别扩大,结果如下

    \begin{equation*}
    \begin{bmatrix}
    x & y & z \\
    \end{bmatrix}
    \begin{bmatrix}
    k_{x} & 0 & 0\\
    0 & k_{y} & 0 \\
    0 & 0 & k_{z} 
    \end{bmatrix} =
    \begin{bmatrix}
    k_{x}x & k_{y}y & k_{z}z \\
    \end{bmatrix}
    \end{equation*}
**** Scaling in an Arbitrary Direction[以任意方向缩放]
    对比按照任意轴进行旋转,按照任意方向缩放与它有共通之处.在此我们考虑,绕任意方向旋转,就是绕 _与_
    _该方向平行的 *基向量* 按一定 *长短* 缩放_,那么,这里就产生了两个参数: *基向量* 和 *长短*.
    在此,我们将问题表示为: $\boldsymbol{S}(\hat{n},k)$
    由此,参考绕任意轴旋转,我们可以得出以下方程:
    $\vec{v} = \vec{v}_{||} + \vec{v}_{\perp}$,
    $\vec{v}_{||} = (\vec{v} \cdot \hat{n}) \hat{n}$,
    $\vec{v'}_{\perp} = \vec{v}_{\perp} = \vec{v} - \vec{v}_{||} = \vec{v} - (\vec{v} \cdot \hat{n}) \hat{n}$,
    $\vec{v'}_{||} = k\vec{v}_{||} = k(\vec{v} \cdot \hat{n}) \hat{n}$,
    $\vec{v'} = \vec{v'}_{||} + \vec{v'}_{\perp} = k(\vec{v} \cdot \hat{n}) \hat{n} + \vec{v} - (\vec{v} \cdot \hat{n}) \hat{n} = \vec{v} + (k-1)(\vec{v}\cdot \hat{n}) \hat{n}$.
    由此,在基向量为$\vec{p}(1,0),\vec{q}(0,1)$ 的2D空间中, 可得:
    \begin{align*}
    \vec{p'} = \vec{p} + (k-1) (\vec{p}\cdot \hat{n}) \hat{n} =
    \begin{bmatrix}
    1 \\
    0 \\
    \end{bmatrix}
    + 
    (k-1) (
    \begin{bmatrix}
    1 \\
    0 \\
    \end{bmatrix}
    \cdot 
    \begin{bmatrix}
    n_{x} \\
    n_{y} \\
    \end{bmatrix}
    ) 
    \begin{bmatrix}
    n_{x} \\
    n_{y} \\
    \end{bmatrix}
    \\=
    \begin{bmatrix}
    1 \\
    0 \\
    \end{bmatrix}
    + (k-1) 
    n_{x}
    \begin{bmatrix}
    n_{x} \\
    n_{y} \\
    \end{bmatrix}
    \\=
    \begin{bmatrix}
    1 \\
    0 \\
    \end{bmatrix}
    +
    \begin{bmatrix}
    (k-1)n_{x^2} \\
    (k-1)n_{x}n_{y} \\
    \end{bmatrix}
    \\=
    \begin{bmatrix}
    1+(k-1)n_{x^2} \\
    (k-1)n_{x}n_{y} \\
    \end{bmatrix}
    \end{align*}

    同理可得,
    \begin{equation*}
    \vec{q} = 
    \begin{bmatrix}
    0 & 1 \\
    \end{bmatrix},
    \vec{q'} = 
    \begin{bmatrix}
    (k-1)n_{x}n_{y} \\
    1+(k-1)n_{y}^2
    \end{bmatrix}
    \end{equation*}
    现在我们知道在2D空间中如何表示任意方向上k的缩放了:
    \begin{equation*}
    \boldsymbol{S}(\hat{n},k) = 
    \begin{bmatrix}
    -\boldsymbol{p'}- \\
    -\boldsymbol{q'}-
    \end{bmatrix} =
    \begin{bmatrix}
    1+(k-1)n_{x^2} & (k-1)n_{x}n_{y}\\
    (k-1)n_{x}n_{y} & 1+(k-1)n_{y^2}
    \end{bmatrix}
    \end{equation*}
    同理,在3D空间中则有:
    \begin{equation*}
    \boldsymbol{S}(\hat{n},k) = 
    \begin{bmatrix}
    -\boldsymbol{p'}- \\
    -\boldsymbol{q'}- \\
    -\boldsymbol{r'}-
    \end{bmatrix} =
    \begin{bmatrix}
    1+(k-1)n_{x^2} & (k-1)n_{x}n_{y} & (k-1)n_{x}n_{z}\\
    (k-1)n_{x}n_{y} & 1+(k-1)n_{y^2} & (k-1)n_{y}n_{z}\\
    (k-1)n_{x}n_{z} & (k-1)n_{y}n_{z} & 1+(k-1)n_{z^2}\\
    \end{bmatrix}
    \end{equation*}
*** 5.3 Orthographic Projection[正交投影]
    简而言之,所谓的 *投影*[projection] 就是一种 *降维操作*.从上一节缩放的知识我们可以推断,在某一个
    方向上将缩放的k值取0,就完成了投影的操作(在2D中被转换为平行的直线,在3D中被转换为一个平面).这种
    投影方式被称作 *正交投影*[orthographic projection],在后面还会学习另一种投影, *透视投影*[perspective
    projection].
***** Projecting onto a Cardinal Axis or Plane[投影到主轴或者平面上]
     最简单的投影就是投影在 *主轴*[cardinal axis](2D) 和 *平面*[plane](3D).
     投影到坐标轴:
     \begin{equation*}
     \boldsymbol{P_{x}} = \boldsymbol{S}(
     \begin{bmatrix}
     0 & 1 \\
     \end{bmatrix}
     ,0) =
     \begin{bmatrix}
     1 & 0 \\
     0 & 0 \\
     \end{bmatrix}
     \end{equation*}

          \begin{equation*}
     \boldsymbol{P_{x}} = \boldsymbol{S}(
     \begin{bmatrix}
     1 & 0 \\
     \end{bmatrix}
     ,0) =
     \begin{bmatrix}
     0 & 0 \\
     0 & 1 \\
     \end{bmatrix}
     \end{equation*}

     投影到平面:

     \begin{equation*}
     \boldsymbol{P_{xy}} = \boldsymbol{S}(
     \begin{bmatrix}
     0 & 0 & 1\\
     \end{bmatrix}
     ,0) =
     \begin{bmatrix}
     1 & 0 & 0\\
     0 & 1  & 0\\
     0 & 0 & 0\\
     \end{bmatrix}
     \end{equation*}

     \begin{equation*}
     \boldsymbol{P_{xz}} = \boldsymbol{S}(
     \begin{bmatrix}
     0 & 1 & 0\\
     \end{bmatrix}
     ,0) =
     \begin{bmatrix}
     1 & 0 & 0\\
     0 & 0  & 0\\
     0 & 0 & 1\\
     \end{bmatrix}
     \end{equation*}

     \begin{equation*}
     \boldsymbol{P_{yz}} = \boldsymbol{S}(
     \begin{bmatrix}
     1 & 0 & 0\\
     \end{bmatrix}
     ,0) =
     \begin{bmatrix}
     0 & 0 & 0\\
     0 & 1  & 0\\
     0 & 0 & 1\\
     \end{bmatrix}
     \end{equation*}
***** Projecting onto an Arbitrary Line or Plane[投影到任意直线或平面]
     参考上一节的内容,只需要将$\hat{n},和k$ 代入即可.
     2D时,
     \begin{equation*}
     \boldsymbol{S}(\hat{n},0) = 
     \begin{bmatrix}
     1+(0-1)n_{x^2} & (0-1)n_{x}n_{y}\\
     (0-1)n_{x}n_{y} & 1+(0-1)n_{y^2}
     \end{bmatrix}=
     \begin{bmatrix}
     1-n_{x^2} & -n_{x}n_{y}\\
     -n_{x}n_{y} & 1-n_{y^2}
     \end{bmatrix}
     \end{equation*}

     3D时,
     \begin{equation*}
     \boldsymbol{S}(\hat{n},k) = 
     \begin{bmatrix}
     1+(0-1)n_{x^2} & (0-1)n_{x}n_{y} & (0-1)n_{x}n_{z}\\
     (0-1)n_{x}n_{y} & 1+(0-1)n_{y^2} & (0-1)n_{y}n_{z}\\
     (0-1)n_{x}n_{z} & (0-1)n_{y}n_{z} & 1+(0-1)n_{z^2}\\
     \end{bmatrix}=
     \begin{bmatrix}
     1-n_{x^2} & -n_{x}n_{y} & -n_{x}n_{z}\\
     -n_{x}n_{y} & 1-n_{y^2} & -n_{y}n_{z}\\
     -n_{x}n_{z} & -n_{y}n_{z} & 1-n_{z^2}\\
     \end{bmatrix}
     \end{equation*}
*** 5.4 Reflection[反射]
    *反射*[reflection],又叫 *镜像*[mirroring], 对象以某条线(2D)或者某个平面(3D)创造一个它的镜像.要完
    成镜像的操作也很简单,参考上一节,我们将 $k$ 的值代换为1就能得到物体的镜像了.
    2D的情况下:
    \begin{equation*}
   \boldsymbol{R}(\hat{n}) = 
   \boldsymbol{S}(\hat{n},-1) = 
   \begin{bmatrix}
   1+(-1-1)n_{x^2} & (-1-1)n_{x}n_{y}\\
   (-1-1)n_{x}n_{y} & 1+(-1-1)n_{y^2}
   \end{bmatrix}=
   \begin{bmatrix}
   1-2n_{x^2} & -2n_{x}n_{y}\\
   -2n_{x}n_{y} & 1-2n_{y^2}
   \end{bmatrix}
   \end{equation*}
    3D的情况下:
    \begin{equation*}
    \boldsymbol{R}(\hat{n}) = 
    \boldsymbol{S}(\hat{n},-1) = 
    \begin{bmatrix}
    1+(-1-1)n_{x^2} & (-1-1)n_{x}n_{y} & (-1-1)n_{x}n_{z}\\
    (-1-1)n_{x}n_{y} & 1+(-1-1)n_{y^2} & (-1-1)n_{y}n_{z}\\
    (-1-1)n_{x}n_{z} & (-1-1)n_{y}n_{z} & 1+(-1-1)n_{z^2}\\
    \end{bmatrix}=
    \begin{bmatrix}
    1-2n_{x^2} & -2n_{x}n_{y} & -2n_{x}n_{z}\\
    -2n_{x}n_{y} & 1-2n_{y^2} & -2n_{y}n_{z}\\
    -2n_{x}n_{z} & -2n_{y}n_{z} & 1-2n_{z^2}\\
    \end{bmatrix}
    \end{equation*}
*** 5.5 Shearing[裁剪]
    *裁剪*[shearing]看起来像是在歪斜坐标空间.与缩放不同的是,裁剪 _不会改变_ 物体的 *面积*[area]和
    *体积*[volume],相同的在于两者都会改变物体的角度大小.
    裁剪变换并不经常被使用,它也被称作 *斜变换*[skew transformation].要注意的是,在同时混合了 *裁剪* 
    和 *缩放* 的变换中,由于两者变换的时候一个不成比例(裁剪),一个成比例(缩放),往往不太能分辨出来.
    在2D空间中,有矩阵如下:
    \begin{equation*}
    \boldsymbol{H}_{x}(s) = 
    \begin{bmatrix}
    1 & 0 \\
    s & 1 \\
    \end{bmatrix}
    \end{equation*}
    \begin{equation*}
    \boldsymbol{H}_{y}(s) = 
    \begin{bmatrix}
    1 & s \\
    0 & 1 \\
    \end{bmatrix}
    \end{equation*}

    其中,x,y各自表示被固定的那个轴,s表示裁剪的大小.
    同理,在3D空间中,有:
    \begin{equation*}
    \boldsymbol{H}_{xy}(s,t) = 
    \begin{bmatrix}
    1 & 0 & 0\\
    0 & 1 & 0 \\
    s & t & 1
    \end{bmatrix}
    \end{equation*}

    \begin{equation*}
    \boldsymbol{H}_{xz}(s,t) = 
    \begin{bmatrix}
    1 & 0 & 0\\
    s & 1 & t \\
    0 & 0 & 1
    \end{bmatrix}
    \end{equation*}

    \begin{equation*}
    \boldsymbol{H}_{yz}(s,t) = 
    \begin{bmatrix}
    1 & s & t\\
    0 & 1 & 0 \\
    0 & 0 & 1
    \end{bmatrix}
    \end{equation*}
*** 5.6 Combining Transformations[组合变换]
    本章节主要讲述的是如何将各种不同的变换(旋转/缩放/投影/反射/裁剪...)组合为一个单一的矩阵.
    组合变换的一个例子是 *渲染*[rendering].想象一下在世界坐标系中有一个任意位置和方向的物体,我们的
    目的是让它在一个给定的 *摄像机*[camera] 下渲染.
    首先,我们要知道它的所有顶点坐标,并且将它们从 *本地空间*[local space] 转移到 *世界空间*[world 
    space],这个过程被叫作 *模型变换*[model transform],用 $\boldsymbol{M}_{wld\to cam}$ 表示.
    然后,我们将变换到世界坐标系的物体的顶点转换到 *摄像机空间*[camera space],这个过程被叫作 *视角变换*[view
    transform],用 $\boldsymbol{M}_{wld \to cam}$ 表示.
    总结如下:
    $\boldsymbol{P}_{wld} = \boldsymbol{P}_{obj} \boldsymbol{M}_{obj \to wld}$,
    $\boldsymbol{P}_{cam} = \boldsymbol{P}_{wld} \boldsymbol{M}_{wld \to cam} = (\boldsymbol{P}_{obj} \boldsymbol{M}_{obj \to wld}) \boldsymbol{M}_{wld \to cam}$.
    $\boldsymbol{P}_{cam} = \boldsymbol{P}_{wld} \boldsymbol{M}_{wld \to cam} = \boldsymbol{P}_{obj} (\boldsymbol{M}_{obj \to wld} \boldsymbol{M}_{wld \to cam})$.
    $\boldsymbol{P}_{cam} = \boldsymbol{P}_{wld} \boldsymbol{M}_{wld \to cam} = \boldsymbol{P}_{obj} (\boldsymbol{M}_{obj \to cam})$.
    以上是从代数角度来描述矩阵乘法,下面我们从几何的方式来了解.
    \begin{equation*}
    \boldsymbol{A}=
    \begin{bmatrix}
    -\boldsymbol{a}_{1}- \\
    -\boldsymbol{a}_{2}- \\
    -\boldsymbol{a}_{3}- \\
    \end{bmatrix},
    \boldsymbol{AB}=
    (
    \begin{bmatrix}
    -\boldsymbol{a}_{1}- \\
    -\boldsymbol{a}_{2}- \\
    -\boldsymbol{a}_{3}- \\
    \end{bmatrix}
    \boldsymbol{B})
    =
    \begin{bmatrix}
    -\boldsymbol{a}_{1} \boldsymbol{B}- \\
    -\boldsymbol{a}_{2} \boldsymbol{B}- \\
    -\boldsymbol{a}_{3} \boldsymbol{B}- \\
    \end{bmatrix}
    \end{equation*}
    在几何方式上,我们将矩阵看成是基向量的集合,而矩阵与矩阵的乘法,就分解成了向量与矩阵的乘法.
*** 5.7 Classes of Transformations[变换的种类]
    当我们讨论 *变换*[transformation]的时候,几乎就等同于在讨论 *映射*[mapping] 或者 *函数*[function].
    简而言之,所谓的 *映射* 就是这样一个规则:接受一个输入,提供一个输出.一个映射可以表示为:
    $F(a) = b$ (read "F of a euqals b")
    同样,变换也是接受一个矩阵,输出另一个矩阵.
**** Linear Transformations[线性变换]
    在映射的角度, *线性变换*[linear transformation]表示为:
    $F(a+b) = F(a) + F(b)$ 
    $F(ka) = kF(a)$
    从矩阵的线性变换来看,可表示为:
    $F(a) = aM$
    $F(a+b) = (a+b)M = aM + bM = F(a) + F(b)$ 
    $F(ka) = (ka)M = k(aM) = kF(a)$
    总结如下:
    1. 任何可以用矩阵乘法实现的变换都是线性变换.
    2. 线性变换 _不包括_ *位移*[translation].
       If $F(0) = a, a \neq 0$  then not a linear translation
    3. 一个线性变换可能会 a)使物体 *伸缩*[stretch],
       但是, b)不会让直线 *变弯*,c) 平行线仍然 *平行*.
       A linear translation may "stretch" things,but straight lines are not "warped" and parallel lines
    remain parallel.
**** Affline Transformations[仿射变换]
    *仿射变换*[affline transformation] = *线性变换*[linear transformation] + *平移*[translation]
    线性变换是仿射变换的 *子集*[subset].每个线性变换都是仿射变换,但是每个仿射变换却不一定是线性变
    换,仿射变换有如下公式:
    $\vec{v'} = \vec{v}M +b$
**** Invertible Transformations[可逆变换]
    *可逆变换*[invertible transformation],类似于对已有的变换做 *撤销*[undo]操作.
    $F^{-1}(F(a)) = F(F^{-1}(a)) = a$ 
    如果对所有的a都能满足上述等式,就说明F(a)是一个可逆变换.现在我们要考虑的是, *仿射变换*[affline 
    transformation] 是否是可逆的?
    我们知道 *仿射变换* = *线性变换* + *位移*,很明显,位移的撤销操作就是取负,那么现在问题就被简化为:
    _线性变换是否可逆_?
    从直觉上来说, *旋转* / *缩放* / *反射* / *裁剪* ,我们都可以进行撤销操作,唯独 *投影*,我们不知道怎么
    怎么搞.
    从前面章节可以知道,所有的线性变换都可以被表达成与矩阵相乘的结果,那么找线性变换的 *逆*[inverse]
    实际上就是找到矩阵的 *逆*.
    如果一个矩阵 _没有逆_,那么它就是一个 *奇异矩阵*[singular matrix].一个 *可逆矩阵* 的 *行列式*[det]
    是 _非零_ 的.
    在一个 *非奇异矩阵* 中,零向量的输入输出是 *一一对应* 的,即输入零向量必然输出零向量,而输入其他向
    量则输出其它非零向量.
    在一个 *奇异矩阵*[singular matrix] 中,零向量的输入输出是 *多对一* 的,即存在多个向量它们的输出结
    果是一个零向量,而这些向量被称作矩阵的 *零空间*[null space].
    一个 *奇异矩阵* 的基向量肯定是 *线性相关*[linearly correlation]的(因为映射是多对一的).我们知道如果
    基向量是 *线性无关*[linearly independent]的,那它是 *满秩*[full rank]的,并且空间中给定的任意向量都是唯
    一确定的.
**** Angle-Preserving Transformations
    如果一个角在转换后它的大小和方向仍然保持不变,我们就把这个变换叫做 *angle-preserving*.

    符合 *angle-preserving* 的变换有
    *平移*[translation] , *旋转*[rotation] , *统一缩放*[uniform scale].

    之所以 *反射*[reflection]变换不符合 *angle-preserving*,是因为在变换后角的方可能变成了它的 *逆*.
    所有的 *angle-preserving* 变换都是 *仿射*[affline] 和 *可逆*[invertible] 的.
**** Orthogonal Transformations[正交变换]
    *Orthogonal* 在之前已经解释过了,它表示 *互相垂直*[perpendicular] 的 *单位向量*[unit length].
    在此 *Orthogonal Matrix* 表示的是它的每个 *行向量* (即基向量) 之间是 *正交* 的.
    符合 *正交变换* 的有:
    *平移*[translation], *旋转*[rotation], *反射*[reflection].
    所有的 *正交变换* 都是 *仿射变换* 并且 *可逆*. 正交变换能保证 _不改变_ 变换后的 *角度大小*, *面积*
    , *体积*,但是却不能保证它们的正负.
**** Rigid Body Transformations[刚体变换]
    *刚体变换*[rigid body transformation] 是一种改变物体 *位置*[position], *方向*[orientation] 但是不改
    变物体 *形状*[shape] 的变换.
    这就意味着, *刚体变换* 不会改变 *角度*, *长度*, *面积* 和 *体积*.同样也意味着, *刚体变换* 满足
    *正交*[orthogonal], *angle-preserving*, *可逆*[invertible] 和 *仿射*[affline].
    从上面的说明可以感受到, *刚体变换* 是限制最多的变换,但是,在实际的游戏开发中,运用的却最多.
** Chapter 6 More On Matrices[更多关于矩阵]
*** 6.1 Determinant of a Matrix[矩阵行列式]
    对 *方阵*[square matrix]而言,这里有一个关于矩阵的特殊 *标量*[scalar] ,被叫做 *行列式*[determinant].行列式在
    线性代数中有很多有用的属性,同时它也有自己的 *几何解释*[geometric interpretations].
**** Determinant of 2 x 2 and 3 x 3 matrices[2x2和3x3矩阵的行列式]
    *方阵* M的行列式表示为 $|\boldsymbol{M}|$ ,或者也被叫做 'det M'.
    一个2 x 2 的方阵的行列式为:
    \begin{equation*}
    |\boldsymbol{M}| =
    \begin{vmatrix}
    m_{11} & m_{12} \\
    m_{21} & m_{22} 
    \end{vmatrix}
    = m_{11}m_{22} -m_{12}m_{21}
    \end{equation*}

    一个3 x 3 的方阵的行列式为:
    \begin{equation*}
    |\boldsymbol{M}| =
    \begin{vmatrix}
    m_{11} & m_{12} & m_{13} \\
    m_{21} & m_{22} & m_{23} \\
    m_{31} & m_{32} & m_{33} \\
    \end{vmatrix} 
    =
    m_{11}m_{22}m_{33} + m_{12}m_{23}m_{31} + m_{13}m_{21}m_{32} -
    m_{13}m_{22}m_{31} - m_{12}m_{21}_m_{33} - m_{11}m_{23}m_{32}
    =
    m_{11}(m_{22}m_{33} - m_{23}m_{32}) - m_{12}(m_{23}m_{31} - m_{21}m_{33}) + m_{13}(m_{21}m_{32} - m_{22}m_{31})
    \end{equation*}

    如果我们把这个3 x 3 的矩阵的行解释成三个向量,则可以表示成:

    \begin{equation*}
    |\boldsymbol{M}| =
    \begin{vmatrix}
    a_{x} & a_{y} & a_{z} \\
    b_{x} & b_{y} & b_{z} \\
    c_{x} & c_{y} & c_{z} \\
    \end{vmatrix} 
    =
    c_{z} (a_{x}b_{y} - a_{y}b_{x}) + c_{y} (a_{z}b_{x} - a_{x}b_{z}) + c_{x} (a_{y}b_{z} - a_{z}b_{y})
    =
    (\vec{a} \times \vec{b})\cdot \vec{c}
    \end{equation*}
**** Minors and Cofactors[余子式和代数余子式]
    假设M是一个r(ow)行c(olumn)列的矩阵.现在考虑从M中减去第i行和第j列,那么剩下的矩阵还有r-1行和c-1
    列.这个 *子矩阵*[submatrix]的 *行列式*[determinant] 被表示为 $M^{\{ij\}}$ ,也被叫做M的 *余子式*[minor].
    e.g
    \begin{equation*}
    \boldsymbol{M}=
    \begin{bmatrix}
    -4 & -3 & 3 \\
    0 & 2 & -2 \\
    1 & 4 & -1 \\
    \end{bmatrix}
    \Longrightarrow
    M^{\{12\}} =
    \begin{vmatrix}
    0 & -2 \\
    1 & -1 \\
    \end{vmatrix} =
    2
    \end{equation*}

    方阵M的 *代数余子式*[cofactor] 除了正负号不确定外,其他与M的 *余子式*[minor] 相同.
    $C^{\{ij\}} = (-1)^{i+j} M^{\{ij\}}$. (注意,结果是一个 *标量*[scalar])
**** Determinants of Arbitrary n x n Matrices[任意方阵的行列式]
    在这里我们使用 *代数余子式*[Cofactors]来定义 *行列式*[determinant].从前面我们知道, *代数余子式*
    [cofactor]是带符号的 *余子式*[minor].而 *行列式*[determinant]是递归的,因为行列式的结果等于任意一行
    或者一列的元素分别与对应的 *代数余子式* 相乘的结果.
    *方阵* -> M, *标量* -> (*行列式*[determinant] , *余子式*[minor] , *代数余子式*[cofactor]).
    注意,矩阵的行列式不仅是一个标量,而且它在几何上可以看成是 _矩阵向量所组成的空间的 *体积*_.
    假设选定任意 *行/列* i,则有公式如下:
    $|\boldsymbol{M}| = \sum _{j=1}^{n}m_{ij} C^{\{ij\}} = \sum _{j=1}^{n}m_{ij} (-1)^{i+j} M^{\{ij\}}$
    则3 x 3 矩阵可表示为:
    \begin{equation*}
    \begin{vmatrix}
    m_{11} & m_{12} & m_{13} \\
    m_{21} & m_{22} & m_{23} \\
    m_{31} & m_{32} & m_{33} \\
    \end{vmatrix} =
    m_{11}
    \begin{vmatrix}
    m_{22} & m_{23} \\
    m_{32} & m_{33} \\
    \end{vmatrix} -
    m_{12}
    \begin{vmatrix}
    m_{21} & m_{23} \\
    m_{31} & m_{33} \\
    \end{vmatrix} +
    m_{13}
    \begin{vmatrix}
    m_{21} & m_{22} \\
    m_{31} & m_{32} \\
    \end{vmatrix}
    \end{equation*}
    4 x 4 矩阵可表示为:
    \begin{equation*}
    \begin{vmatrix}
    m_{11} & m_{12} & m_{13} & m_{14}\\
    m_{21} & m_{22} & m_{23} & m_{24}\\
    m_{31} & m_{32} & m_{33} & m_{34}\\
    m_{41} & m_{42} & m_{43} & m_{44}\\
    \end{vmatrix} =
    m_{11}
    \begin{vmatrix}
    m_{22} & m_{23} & m_{24}\\
    m_{32} & m_{33} & m_{34}\\
    m_{42} & m_{43} & m_{44}\\
    \end{vmatrix} -
    m_{12}
    \begin{vmatrix}
    m_{23} & m_{24} & m_{21}\\
    m_{33} & m_{34} & m_{31}\\
    m_{43} & m_{44} & m_{41}\\
    \end{vmatrix} +
    m_{13}
    \begin{vmatrix}
    m_{24} & m_{21} & m_{22}\\
    m_{34} & m_{31} & m_{32}\\
    m_{44} & m_{41} & m_{42}\\
    \end{vmatrix} -
    m_{14}
    \begin{vmatrix}
    m_{21} & m_{22} & m_{23}\\
    m_{31} & m_{32} & m_{33}\\
    m_{41} & m_{42} & m_{43}\\
    \end{vmatrix}
    \end{equation*}
    展开后,可以得到:
    \begin{equation*}
    \begin{align}
    m_{11}
    [
    m_{22}(m_{33}m_{44} - m_{34}m_{43}) + 
    m_{23}(m_{34}m_{42} - m_{32}m_{44}) +
    m_{24}(m_{32}m_{43} - m_{33}m_{42})
    ]
    \\-
    m_{12}
    [
    m_{23}(m_{34}m_{41} - m_{31}m_{44}) + 
    m_{24}(m_{31}m_{43} - m_{33}m_{41}) +
    m_{21}(m_{33}m_{44} - m_{34}m_{43})
    ]
    \\+
    m_{13}
    [
    m_{24}(m_{31}m_{42} - m_{32}m_{41}) + 
    m_{21}(m_{32}m_{44} - m_{34}m_{42}) +
    m_{22}(m_{34}m_{41} - m_{31}m_{44})
    ]
    \\-
    m_{14}
    [
    m_{21}(m_{32}m_{43} - m_{33}m_{42}) + 
    m_{22}(m_{33}m_{41} - m_{31}m_{43}) +
    m_{23}(m_{31}m_{42} - m_{32}m_{41})
    ]
    \end{align}
    \end{equation*}

    由此,我们简要说明一些行列式的相关特性: (从行列式的 _几何解释_ 来理解)
    - *单位矩阵*[identity matrix]的行列式等于1.
      $|\boldsymbol{I}| = 1$

    - 矩阵乘积的行列式等于各个矩阵行列式相乘.
      $\boldsymbol{|A||B| = |A||B|}$
      $\boldsymbol{|M_{1} M_{2} ... M_{n}| = |M_{1}| |M_{2}| ... |M_{n}|}$

    - 转置矩阵与原矩阵的行列式相等.
      $\boldsymbol{|M^T| } = \boldsymbol{|M|}$

    - 只要矩阵内有 _任何一行或者一列_ 为0,则矩阵的行列式结果为0.
    \begin{equation*}
    \begin{vmatrix}
    ? & ? & ? & ? \\
    0 & 0 & 0 & 0 \\
    ? & ? & ? & ? \\
    ? & ? & ? & ? \\
    \end{vmatrix}
    =
    \begin{vmatrix}
    ? & ? & 0 & ? \\
    ? & ? & 0 & ? \\
    ? & ? & 0 & ? \\
    ? & ? & 0 & ? \\
    \end{vmatrix}
    = 0
    \end{equation*}

    - *互换*[exchanging] 矩阵中的某行或某列会改变行列式的正负.
    \begin{equation*}
    \begin{vmatrix}
    m_{11} & m_{12} & m_{13} \\
    m_{21} & m_{22} & m_{23} \\
    m_{31} & m_{32} & m_{33} \\
    \end{vmatrix}
    = -
    \begin{vmatrix}
    m_{11} & m_{12} & m_{13} \\
    m_{31} & m_{32} & m_{33} \\
    m_{21} & m_{22} & m_{23} \\
    \end{vmatrix}
    \end{equation*}

    - 把k倍大小的行(或列)添加到另一个矩阵的行(或列)中,并不会改变行列式的值.
    \begin{equation*}
    \begin{vmatrix}
    m_{11} & m_{12} & m_{13} \\
    m_{21} & m_{22} & m_{23} \\
    m_{31} & m_{32} & m_{33} \\
    \end{vmatrix}
    =
    \begin{vmatrix}
    m_{11} & m_{12} & m_{13} \\
    m_{31}+km_{21} & m_{32}+km_{22} & m_{33}+km_{22}\\
    m_{21} & m_{22} & m_{23} \\
    \end{vmatrix}
    \end{equation*}
**** Geometric Interpretation of Determinant[行列式的几何解释]
    矩阵行列式有一个有趣的几何解释.
    在2D中,矩阵行列式等于 _向量围成的平行四边形的带符号面积_.(如果行列式结果为负,表示围成的平行四
    边形相对于原点 *翻转*[flipped]了).
    在3D中,矩阵行列式等于 _向量围成的平行六面体的体积_.(如果行列式结果为负,表示围成的是 *反射*
    [reflected] 后的平行四边形,同样也是 *翻转*[turned inside out]了.
    行列式与矩阵变换的大小变化有关.行列式的绝对值表示的是矩阵变换后的 *面积*[area](2D) 或者 *体积*
    [volume](3D).而带的符号(正负)则表明了该矩阵中是否包含了 *反射* 或者 *投影*.
    因而我们可以通过观察矩阵行列式来判断该矩阵的类型.
*** 6.2 Inverse of a Matrix[矩阵的逆]
    除了矩阵的 *行列式*[determinant] 要求矩阵必须是 *方阵*[square matrix] 外,矩阵的 *逆*[inverse]也有
    同样的要求.
    假设存在方阵 $\boldsymbol{M}$,则方阵的逆为$\boldsymbol{M^{-1}}$,则存在关系:
    $\boldsymbol{MM^{-1}} = \boldsymbol{M^{-1}M} = \boldsymbol{I}$
    并不是所有的矩阵都有 *逆*.一个明显的例子是一行或者一列全是0的矩阵无论与其他什么矩阵相乘,相关
    行或列的结果都只能是0.
    一个 _存在逆矩阵_ 的矩阵被叫做 *invertible*[可逆矩阵] 或者 *nonsingular*[非奇异矩阵].
    det != 0 --> 可逆矩阵 --> 非奇异矩阵 --> 线性无关
    一个 _不存在逆矩阵_ 的矩阵被叫做 *noneinvertible*[不可逆矩阵] 或者 *singular*.
    det ==0 --> 不可逆矩阵 ---> 奇异矩阵 --> 线性相关

    对任何 *可逆矩阵* 来说,存在 $\vec{v}M = 0$ 的原因只可能是 $\vec{v} = 0$.
    进一步来说, *可逆矩阵* 的行或者列之间必然是 *线性无关*[linearly independent]的.
**** The Classical Adjoint[伴随矩阵]
    矩阵的 *逆*[inverse] 是通过 *伴随矩阵*[classical adjoint]来计算的.矩阵M的伴随矩阵写做 $adj \boldsymbol{M}$,被定
义为由 _M的余子式组成的矩阵的转置_ (the transpose of the matrix of cofactors of M).
    假设有一 3 x 3 矩阵如下:
\begin{equation*}
\boldsymbol{M} =
\begin{bmatrix}
-4 & -3 & 3 \\
0 & 2 & -2 \\
1 & 4 & -1
\end{bmatrix}
\end{equation*}

    1) 计算M的 *余子式*[cofactors],
       $C^{\{11\}} = + 6 = 6$, ... , ... , 
       $C^{\{33\}} = +(-8) = -8$
    2) 转置矩阵 $adj \boldsymbol{M}$ 就表达为:
    \begin{equation*}
    adj \boldsymbol{M} =
    \begin{vmatrix}
    C^{\{11\}} & C^{\{12\}} & C^{\{13\}}\\
    C^{\{21\}} & C^{\{22\}} & C^{\{23\}}\\
    C^{\{31\}} & C^{\{32\}} & C^{\{33\}}\\
    \end{vmatrix}^T
    \\=
    \begin{vmatrix}
    6 & -2 & -2 \\
    9 & 1 & 13 \\
    0 & -8 & -8
    \end{vmatrix}^T
    \\=
    \begin{vmatrix}
    6 & 9 & 0 \\
    -2 & 1 & -8 \\
    -2 & 13 & -8
    \end{vmatrix}
    \end{equation*}
**** Matrix Inverse - Official Linear Algebra Rules[可逆矩阵在线性代数中的规则]
    计算矩阵的逆的公式如下:
    $\boldsymbol{M}^{-1} = \frac{adj \boldsymbol{M}} {\boldsymbol{|M|}}$.
    从公式可以看出来,$\boldsymbol{|M|}$ 是不能为0的.这就是我们为什么说行列式为0的矩阵时不可逆矩阵的原因.
    还有其他计算矩阵的逆的方法,一个典型的方法是 *高斯消元法*[Gaussian elimination].
    现在我们来总结一下矩阵的逆的相关信息:
    - 矩阵的逆的逆就是原矩阵.
      $(\boldsymbol{M^{-1}})^{-1} = \boldsymbol{M}$
    - 单位矩阵的逆就是它自己.
      $\boldsymbol{I^{-1}} = \boldsymbol{I}$
    - 转置矩阵的逆等于逆矩阵的转置.
      $(\boldsymbol{M^{T}})^{-1} = (\boldsymbol{M^{-1}})^{T}$
    - 矩阵积的逆等于反向的矩阵的逆的积
      $\boldsymbol{(AB)^{-1}} = \boldsymbol{B^{-1}A^{-1}}$,
      也即是:
      $\boldsymbol{(M_{1}M_{2}...M_{n})^{-1}} = \boldsymbol{M_{n}^{-1} M_{n-1}^{-1} ... M_{1}^{-1}}$
    - 矩阵的逆的行列式值等于原矩阵行列式的倒数.
      $\boldsymbol{|M^{-1}| = 1 / |M|}$
**** Matrix Inverse - Geometric Interpretation[可逆矩阵的几何解释]
    可逆矩阵的几何解释,直观上来看很容易理解,根据公式:
    $\boldsymbol{(vM)M^{-1} = v(MM^{-1}) = vI = v}$.
    可知,可逆矩阵其实是在对矩阵的变换做一个 *撤销*[undo]操作.
*** 6.3 Orthogonal Matrices[正交矩阵]
**** Orthogonal Matrices - Official Linear Algebra Rules[正交矩阵在线性代数中的规则]
    定义如下: _当且仅当_ *方阵* 与其 *转置矩阵*[transpose] 之 *积*[product] 是 *标准矩阵*[identity matrix]
时,我们才说该矩阵是 *正交矩阵*[orthogonal matrix].注意这里的符号 $\Longleftrightarrow$ 表示两者是可以互相推导的.
    $\boldsymbol{M(orthogonal)} \Longleftrightarrow  \boldsymbol{MM^{T} = I}$
    同时,由上一节得到的公式 $\boldsymbol{MM^{-1} = I}$,可得:
    $\boldsymbol{M(orthogonal)} \Longleftrightarrow  \boldsymbol{M^{T} = M^{-1}}$
    *注意*,这是一个 _超级有用_ 的公式,因为 *矩阵的逆*[inverse of a matrix] 会经常被用到,而 *正交矩阵*
[orthogonal matrices]在3D图形中出现的非常频繁.一个典型的例子就是 *旋转* 和 *反射* 变换的矩阵都是正
交的.如果我们知道一个矩阵是正交的,那么我们就可以使用矩阵的 *转置* 而不是矩阵的 *逆* 来做计算(因为
矩阵的逆需要进行更多的运算).
**** Orghogonal Matrices - Geometric Interpretation[正交矩阵的几何解释]
    在很多情况下,我们是先知道矩阵会做什么变换,进而使用该矩阵做出变换的操作.但是,如果我们事先不知道
这是个进行什么变换的矩阵,比如只是告诉你有一个正交矩阵,会出现什么情况呢?
    现在,假设存在一个 3 x 3 的矩阵M,根据前面的公式,可推出如下结果:
    $\boldsymbol{MM^{T} = I}$,
    \begin{equation*}
    \begin{bmatrix}
    m_{11} & m_{12} & m_{13} \\
    m_{21} & m_{22} & m_{23} \\
    m_{31} & m_{32} & m_{33} \\
    \end{bmatrix}
    \begin{bmatrix}
    m_{11} & m_{21} & m_{31} \\
    m_{12} & m_{22} & m_{32} \\
    m_{13} & m_{23} & m_{33} \\
    \end{bmatrix} =
    \begin{bmatrix}
    1 & 0 & 0 \\
    0 & 1 & 0 \\
    0 & 0 & 1 \\
    \end{bmatrix}
    \end{equation*}
    用向量 $r_{1},r_{2},r_{3}$ 分别表示M的行,则有:
    \begin{equation*}
    r_{1} =
    \begin{bmatrix}
    m_{11} & m_{12} & m_{13} \\
    \end{bmatrix}
    r_{2} =
    \begin{bmatrix}
    m_{21} & m_{22} & m_{23} \\
    \end{bmatrix}
    r_{3} =
    \begin{bmatrix}
    m_{31} & m_{32} & m_{33} \\
    \end{bmatrix}
    \end{equation*}
    \begin{equation*}
    \boldsymbol{M} =
    \begin{bmatrix}
    \boldsymbol{-r1-} \\
    \boldsymbol{-r2-} \\
    \boldsymbol{-r3-} \\
    \end{bmatrix}
    \end{equation*}
    根据以上条件,则有:
    $r_{1} \cdot r_{1} = 1$, $r_{1} \cdot r_{2} = 0$, $r_{1} \cdot r_{3} = 0$,
    $r_{2} \cdot r_{1} = 0$, $r_{2} \cdot r_{2} = 1$, $r_{2} \cdot r_{3} = 0$,
    $r_{3} \cdot r_{1} = 0$, $r_{3} \cdot r_{2} = 0$, $r_{3} \cdot r_{3} = 1$.
    从上面我们可以得出如下结论:
    - 只有 *单位向量*[unit vector]与自己的点积结果才可能等于1.
    - 如果两个向量的点积结果为0,原因只能是这两个向量互相 *垂直*[perpendicular].

    所以,如果一个矩阵是 *正交矩阵*,那么:
    - 矩阵的每行(列)都是 *单位向量*.
    - 矩阵的行(列)向量必然互相 *垂直*.
    之前我们就说过 *正交基*[orthogonal basis]在3D图形学中极其有用,而现在我们又了解了它的另一特性,
即 _正交矩阵的转置与它的逆相等_.
    由于点积符合 *交换律*[commutative],所以上面的9个等式实际上可以简化为6个.
    $r_{1} \cdot r_{1} = 1$, $r_{1} \cdot r_{2} = 0$, $r_{1} \cdot r_{3} = 0$,
    $r_{2} \cdot r_{2} = 1$, $r_{2} \cdot r_{3} = 0$,
    $r_{3} \cdot r_{3} = 1$.
    通常情况下,在考虑计算矩阵的 *逆* 时,最好的情况是提前知道该矩阵是否是 *正交矩阵*.如果在不知道是
否正交的情况下先判断正交会浪费很多时间,就算判断成功,再转置该矩阵的情况下与直接计算矩阵的逆效率
上也差不了多少了.而如果失败,那么我们用来判断正交的时间就浪费了.

    *注意*,这里详细的解释一些术语.
    如果一组 *基向量*[basis vecotrs] 是互相 *垂直*[perpendicular]的,我们就说它们是 *正交*[orthogonal]
的,更进一步,如果基向量还是 *单位向量*[unit vector],这组向量就叫做 *标准正交基*[orthonormal basis].
由此,一个 *正交矩阵*[orthogonal matrix]的行或者列都是 *标准正交基向量*[orthonormal basis vectors].但是
反过来看,一组 *正交基向量* 并不保证能构成一个 *正交矩阵* (除非基向量是 *标准正交基*).
    *orthonormal* --> *标准正交*,
    *orthogonal* --> *正交*.
**** Orthogonalizing a Matrix[矩阵正交化]
    构建 *正交基向量*[orthogonal basis vectors]的标准算法叫做 *Gram-Schimidt orthogonalization*.基
本的想法是按顺序浏览基向量.
    For each basis vector, we subtract off the portion of that vector that is parallel to the proceeding
basis vectors,which must result in a perpendicular vector.
    对每个基向量而言,我们减去它平行于下一个基向量的那部分,就一定会得到一个垂直的向量.
    假设存在一个$3 \times 3$ 的矩阵$\boldsymbol{M}$ ,它的行向量分别用 $r_{1},r_{2},r_{3}$ 表示,那么这一组
正交的行向量可以被表示为:
    $\boldsymbol{r^{'}_{1} \Leftarrow r_{1}}$,
    $\boldsymbol{r^{'}_{2} \Leftarrow r_{2} - \frac{r_{2} \cdot r^{'}_{1}} {r^{'}_{1} \cdot r^{'}_{1}} r^{'}_{1}}$,
    $\boldsymbol{r^{'}_{3} \Leftarrow r_{3} - \frac{r_{3} \cdot r^{'}_{1}} {r^{'}_{1} \cdot r^{'}_{1}} r^{'}_{1} - \frac{r_{3} \cdot r^{'}_{2}} {r^{'}_{2} \cdot r^{'}_{2}} r^{'}_{2}}$
    在应用这些步骤后,会得到互相垂直的向量 $r_{1},r_{2},r_{3}$,从而形成一组 *正交基*,虽然它们不一定是 *单位向量*.
而因为我们需要一组 *标准正交基*[orthonormal basis]来构造 *正交矩阵*[orthogonal matrix],所以我们必须
要 *标准化*[normalize] 这些向量.
    而在3D空间中,我们还能使用一个特殊的技巧-*叉积*[cross product]来初始化第三个基向量.
    $\boldsymbol{r^{'}_{3} \Leftarrow r^{'}_{1} \times r^{'}_{2}}$
*** 6.4 4 x 4 Homogeneous Matrices[齐次矩阵]
    在前面的章节里我们只涉及了2D和3D向量,现在我们将介绍4D向量,也被叫做 *齐次空间*[homogeneous 
coordinate].
    首先,我们要知道 *齐次*[homogeneous]是什么意思,其实 *齐次坐标*,也叫 *投影坐标*,是指一个用于投影几
何的坐标系统.
    使用齐次矩阵的原因很简单,在3D空间的变换中需要频繁使用 *位移*[translation],但是3D矩阵无法实现
*仿射变换*[affline transformation],而在4x4的齐次矩阵中,则能满足 *仿射变换* (位移 + 线性变换).
**** 4D Homogeneous Space[4D齐次空间] 
    4D向量由四部分组成(x,y,z,w),其中w通常被叫做 *齐次坐标*[homogeneous coordinate].
    为了理解标准的物理3D空间是怎么被扩展成4D空间的,我们先来理解2D空间中的齐次坐标,在此我们把它表
示为$(x,y,w)$.我们把一个标准的2D平面放在一个3D空间中,假设平面$w=1$,就像2D的点$(x,y)$ 在齐
次坐标空间中就是$(x,y,1)$.
    而对于那些不在 *平面*[plane] $w =1$ 的点,则可以通过除以 $w$ 来投影到相关的2D坐标上.所以齐次坐标
$(x,y,w)$ 就被映射成了2D的点 $(x/w,y/w)$.
    对任何2D中给定的点$(x,y)$,在齐次坐标空间中都有无数相关的点,所有的格式$(kx,ky,k)$,都证明$k \neq 0$.
    这些点穿过齐次坐标,构成了一条线.
    当$w=0$,除法是未定义的并且不能在其中找到相关的点.但是可以把$(x,y,0)$解释成一个 _无限远的点_,它
被定义为 *方向*[orientation] 而不是 *位置*[location].
    当我们想从概念上区别 *点*[points]和 *向量*[vector]时, 记住 $w \neq 0$ 时,代表的是 *点*[points],而
$w=0$ 时,代表的是 *向量*[vector].
**** 4 x 4 Translation Matrices[位移矩阵]
    由于3 x 3 的矩阵只能表示 *线性变换*[linear transformation],而 *位移*[translation]又是在实际应用里
频繁遇到的情况,所以为了包含这两种变换,我们需要能满足 *仿射变换*[affline transformation]的矩阵.而为
了满足这个要求,我们需要将3 x 3的矩阵扩展成 4 x 4 的矩阵.
    假设 $w = 1$,那么一个3D向量$[x,y,z]$,在4D中就可以被表示为$[x,y,z,1]$,而一个矩阵则转换如下:
\begin{equation*}
\begin{bmatrix}
m_{11} & m_{12} & m_{13} \\
m_{21} & m_{22} & m_{23} \\
m_{31} & m_{32} & m_{33} \\
\end{bmatrix}
\Rightarrow
\begin{bmatrix}
m_{11} & m_{12} & m_{13}  & 0\\
m_{21} & m_{22} & m_{23} & 0\\
m_{31} & m_{32} & m_{33} & 0\\
0 & 0 & 0 & 1
\end{bmatrix}
\end{equation*}
    当我们让向量与矩阵相乘时,有如下结果:
\begin{equation*}
\begin{bmatrix}
x & y & z\\
\end{bmatrix}
\begin{bmatrix}
m_{11} & m_{12} & m_{13} \\
m_{21} & m_{22} & m_{23} \\
m_{31} & m_{32} & m_{33} \\
\end{bmatrix} 
=
\begin{bmatrix}
xm_{11}+ym_{21}+zm_{31} &
xm_{12}+ym_{22}+zm_{32} &
xm_{13}+ym_{23}+zm_{33}
\end{bmatrix}
\end{equation*}

\begin{equation*}
\begin{bmatrix}
x & y & z & 1\\
\end{bmatrix}
\begin{bmatrix}
m_{11} & m_{12} & m_{13} & 0\\
m_{21} & m_{22} & m_{23} & 0\\
m_{31} & m_{32} & m_{33} & 0\\
0 & 0 & 0 & 1\\
\end{bmatrix} 
=
\begin{bmatrix}
xm_{11}+ym_{21}+zm_{31} &
xm_{12}+ym_{22}+zm_{32} &
xm_{13}+ym_{23}+zm_{33} &
1
\end{bmatrix}
\end{equation*}
    有趣的地方来了,从上面的矩阵来看,我们可以在第四行上加入 *平移*[translation].而方法是将 *平移* 当作
矩阵加法.
\begin{equation*}
\begin{bmatrix}
x & y & z & 1\\
\end{bmatrix}
\begin{bmatrix}
1 & 0 & 0 & 0 \\
0 & 1 & 0 & 0 \\
0 & 0 & 1 & 0 \\
\Delta x & \Delta y & \Delta z & 1
\end{bmatrix} 
=
\begin{bmatrix}
x+\Delta x & y+\Delta y & z+\Delta z & 1
\end{bmatrix}
\end{equation*}
    这个矩阵加法依然是 *线性变换*[linear transformation].在4D中,矩阵加法并不能代替 *位移*[translation],
并且4D的零向量总会变换回零向量.而之所能成功的原因是我们实际上在 *裁剪*[shearing] 4D空间,想想之前
我们看过的裁剪矩阵,在4D中做 *裁剪*,展现在3D空间的效果就是 *位移*.(想想3D空间中裁剪,2D空间的表现)
    现在考虑如何完成旋转和平移.令矩阵 $\boldsymbol{R}$ 为 *旋转矩阵*,矩阵 $\boldsymbol{T}$ 为 *位移矩阵*,则有等式如下:
\begin{equation*}
\boldsymbol{R} =
\begin{bmatrix}
r_{11} & r_{12} & r_{13} & 0 \\
r_{21} & r_{22} & r_{23} & 0 \\
r_{31} & r_{32} & r_{33} & 0 \\
0 & 0 & 0 & 1 \\
\end{bmatrix},
\boldsymbol{T} =
\begin{bmatrix}
1 & 0 & 0 & 0 \\
0 & 1 & 0 & 0 \\
0 & 0 & 1 & 0 \\
\Delta x & \Delta y & \Delta z & 1 \\
\end{bmatrix}.
\end{equation*}
    现在我们让向量 $\vec{v}$ 来进行 *旋转* + *平移* 变换,有等式:
    $\vec{v}^{'} = \vec{v} \boldsymbol{RT} = \vec{v} \boldsymbol{(RT)} = \vec{v} \boldsymbol{M}$
    可得 $\boldsymbol{M}$ 如下:
    \begin{equation*}
    \boldsymbol{M=RT=}
    \begin{bmatrix}
    r_{11} & r_{12} & r_{13} & 0 \\
    r_{21} & r_{22} & r_{23} & 0 \\
    r_{31} & r_{32} & r_{33} & 0 \\
    \Delta x & \Delta y & \Delta z & 1\\
    \end{bmatrix}
    \end{equation*}

    仔细观察,其实矩阵 $\boldsymbol{M}$ 由三部分组成, *旋转矩阵*, *平移矩阵*,以及最右边的向量.那么,我们
就可以将其化简为:
\begin{equation*}
\boldsymbol{M=}
\begin{bmatrix}
R & 0 \\
T & 1 \\
\end{bmatrix}
\end{equation*}
    让我们先考虑 *无穷远点*[points at infinity]的情况$(x,y,z,w)$,其中 $w=0$.
    \begin{equation*}
    \begin{bmatrix}
    x & y & z & 0 \\
    \end{bmatrix}
    \begin{bmatrix}
    r_{11} & r_{12} & r_{13} & 0 \\
    r_{21} & r_{22} & r_{23} & 0 \\
    r_{31} & r_{32} & r_{33} & 0 \\
    0 & 0 & 0 & 1\\
    \end{bmatrix}
    =
    \begin{bmatrix}
    xr_{11} + yr_{21} + zr_{31} & xr_{12} + yr_{22} + zr_{32} & xr_{13} + yr_{23} + zr_{33} & 0\\
    \end{bmatrix}
    \end{equation*}
    从上面的线性变换结果可以看出,向量$(w=0)$ 与矩阵相乘,最终得到的是形如 $[x^{'},y^{'},z^{'},0]$ 的结果.
    如果我们再加入 *位移变换*,结果如下:
    \begin{equation*}
    \begin{bmatrix}
    x & y & z & 0 \\
    \end{bmatrix}
    \begin{bmatrix}
    r_{11} & r_{12} & r_{13} & 0 \\
    r_{21} & r_{22} & r_{23} & 0 \\
    r_{31} & r_{32} & r_{33} & 0 \\
    \Delta x & \Delta y & \Delta z & 1\\
    \end{bmatrix}
    =
    \begin{bmatrix}
    xr_{11} + yr_{21} + zr_{31} & xr_{12} + yr_{22} + zr_{32} & xr_{13} + yr_{23} + zr_{33} & 0\\
    \end{bmatrix}
    \end{equation*}
    可见,在$w=0$ 的情况下, *位移* 变换是无效的.所以,这里的 $w$ 的值就成了一个左右 *位移* 的参数.这在实
际应用中非常的频繁,因为 *位移* 的是一些表示 *位置* 的向量,而一些仅仅表示 *方向* 的向量(如 *法线*
[surface normal]),是不应该被移动的.
    总结一下就是,
    第一种情况,在 $w=1$ 的时候,是作为 *点*[points],表示 *位置*[location]信息,进行位移.
    第二种情况,在 $w=0$ 的时候,是作为 *向量*[vector],表示 *方向*,不进行位移.
    虽然说最右边的 $[0,0,0,1]^T$ 没有什么实际意义,因为一个$4 \times 3$ 的矩阵就能完成 *线性变换* + *平移*.
但是,由于矩阵的运算和方阵的性质更方便计算,采用 $4 \times 4$ 矩阵是更优的选择.
**** General Affine Transformations[仿射变换]
    第五章介绍了 *线性变换*[linear transformation] 中的几种基本变换,而没有考虑 *位移*[translation].主
要原因在于 $3 \times 3$ 的矩阵只能表示 *线性变换*.现在我们的装备已经升级了:),通过 $4 \times 4$ 矩阵,我们现在已经
能完成 *仿射变换*[affine transformation]了.
    比如:
     - rotation about an axis that does not pass through the origin.
     - scale about a plane that does not pass through the origin.
     - reflection about a plane that doest not pass through the origin.
     - otrhographic projection onto a plane that does not pass through the origin.
    基本的做法是,先位移到原点,进行线性变换,再撤销位移.假设位移到原点的变换矩阵为 $T$ ,旋转矩阵为$R$,
再位移回之前的位置就是 $T^{-1}$.
    那么,我们有矩阵如下:
\begin{equation*}
\begin{align*}
\boldsymbol{T}=
\begin{bmatrix}
1 & 0 & 0 & 0 \\
0 & 1 & 0 & 0 \\
0 & 0 & 1 & 0 \\
-p_{x} & -p_{y} & -p_{z} & 1
\end{bmatrix} =
\begin{bmatrix}
\boldsymbol{I} & 0 \\
\boldsymbol{-p} & 1 \\
\end{bmatrix}
\\
\boldsymbol{R}=
\begin{bmatrix}
r_{11} & r_{12} & r_{13} & 0 \\
r_{21} & r_{22} & r_{23} & 0 \\
r_{31} & r_{32} & r_{33} & 0 \\
0 & 0 & 0 & 1 \\
\end{bmatrix} =
\begin{bmatrix}
\boldsymbol{R_{3 \times 3}} & 0 \\
0 & 1
\end{bmatrix}
\\
\boldsymbol{T^{-1}=}
\begin{bmatrix}
1 & 0 & 0 & 0 \\
0 & 1 & 0 & 0 \\
0 & 0 & 1 & 0 \\
p_{x} & p_{y} & p_{z} & 1
\end{bmatrix} =
\begin{bmatrix}
\boldsymbol{I} & 0 \\
\boldsymbol{p} & 1 \\
\end{bmatrix}
\end{align*}
\end{equation*}
    化简后,可得:
    \begin{equation*}
    \boldsymbol{TRT^{-1}} =
    \begin{bmatrix}
    \boldsymbol{I} & 0 \\
    \boldsymbol{-p} & 1 \\
    \end{bmatrix}
    \begin{bmatrix}
    \boldsymbol{R_{3 \times 3}} & 0 \\
    0 & 1
    \end{bmatrix}
    \begin{bmatrix}
    \boldsymbol{I} & 0 \\
    \boldsymbol{p} & 1 \\
    \end{bmatrix}=
    \begin{bmatrix}
    \boldsymbol{R_{3 \times 3}} & 0 \\
    \boldsymbol{-p(R_{3 \times 3})+p} & 1
    \end{bmatrix}.
    \end{equation*}
    从等式可以看出, 只有 *位移矩阵* 发生了变化.
    现在 "*齐次空间*" 的作用仅仅体现在实现 *仿射变换*.之所以我们要在这里加引号,是因为$w$的值总是取1(
或者0),在下一节将讨论更多的 $w$ 的取值所展现的意义.
*** 6.5 4 x 4 Matrices and Perspective Projection[矩阵和透视投影]
    当我们在讨论投影时,通常讨论的是两种情况: 
    *透视投影*[perspective projection] 和 *正交投影*[orthographic projection].
    *正交投影* 也叫 *平行投影*[parallel projection],原因就在于物体投影前后是平行的.
    *projection plane*[投影平面],物体投射到的平面.
    *projector* -> 代指从原物体的点到对应的投影平面上的点 _连成的直线_.
    *平行投影* 使用平行的 *projectors*.
    *透视投影* 中, *projectors* 形成的直线交于一点,改点被叫做 *投影中心*[center of projection].
    两者真正的区别在不同的距离上,在 *正交投影* 中,由于 *projector* 是平行的,所以距离的远近不改变投影
的大小,而在 *透视投影* 中, *投影中心* 点的位置不同,将会对投影大小产生重大的影响,这种视觉差异被叫做
*透视收缩*[foreshortening].
**** A Pinhole Camera[针孔相机]
    *透视投影* 在3D中之所以如此重要,是因为和我们人眼的机制一致.实际上人眼更为复杂,因为每只眼睛的投
影表面(视网膜)都不是平坦的.
    *针孔相机*[pinhole camera]的成像原理与我们视网膜的成像原理是一致的.对任意一点 $p$,存在对应的投影
    平面中的点 $p^{'}$,其中$p$ 是穿过了 *针孔*[pinhole] 再投影到投影平面的.假设 *针孔* 到投影平面的距离为 $d$,
平面为$z$ ,显然可得: $z = -d$.
    又因为相似三角形的边对应成比例,因而有:
    \begin{equation*}
    \frac{-p_{y}^{'}}{d} = \frac {p_{y}}{z} \Rightarrow p_{y}^{'} = \frac{-dp_{y}} {z}.
    \end{equation*}
    同理,有 $p^{'}_{x} = \frac{-dp_{x}}{z}$.
    由此可得:
    \begin{equation*}
    \boldsymbol{p} =
    \begin{bmatrix}
    x & y  & z \\
    \end{bmatrix}
    \Rightarrow
    \boldsymbol{p^{'}} = 
    \begin{bmatrix}
    -dx/z & -dy/z  & -d \\
    \end{bmatrix}
    \end{equation*}
    在另一种情况下 $(z = d)$,即 _投影平面在投影中心之前_,那么我们的距离 $d$ 就不再为负,则有:
     \begin{equation*}
    \boldsymbol{p} =
    \begin{bmatrix}
    x & y  & z \\
    \end{bmatrix}
    \Rightarrow
    \boldsymbol{p^{'}} = 
    \begin{bmatrix}
    dx/z & dy/z  & d \\
    \end{bmatrix}
    \end{equation*}
**** Perspective Projection Matrices[透视投影矩阵]
    我们知道4D齐次矩阵转换到3D需要用到除法.我们可以在一个 $4 \times 4$ 的矩阵中构造 *透视投影*.在4D齐次
矩阵中,向量表示为 $[x,y,z,w]$ ,假设 $w=1$ ,根据上一节公式:
    \begin{equation*}
    \boldsymbol{p} =
    \begin{bmatrix}
    x & y  & z \\
    \end{bmatrix}
    \Rightarrow
    \boldsymbol{p^{'}} = 
    \begin{bmatrix}
    dx/z & dy/z  & d \\
    \end{bmatrix} = 
    \begin{bmatrix}
    dx & dy  & dz \\
    \end{bmatrix}     
    =
    \frac 
    {
    \begin{bmatrix}
    x & y  & z \\
    \end{bmatrix}     }
    {z/d}
    \end{equation*}
    则有4D向量$[x,y,z,z/d]$,考虑到 $\vec{v}^{'} = \vec{v}M$,则有:
    \begin{equation*}
    \begin{bmatrix}
    x & y & z & 1
    \end{bmatrix}
    M=
     \begin{bmatrix}
    x & y & z & z/d
    \end{bmatrix},
    M = 
     \begin{bmatrix}
     1 & 0 & 0 & 0 \\
     0 & 1 & 0 & 0 \\
     0 & 0 & 0 & 1/d \\
     0 & 0 & 0 & 0
    \end{bmatrix}.
    \end{equation*}
    矩阵$M$ 即是 *透视投影矩阵*.
    总结如下:
    - 与 *透视投影矩阵* 相乘并不能真正表示 *透视变换*.它只是在为w计算适当的分母.
    - w可以取很多值,不同的值有不同的意义.
    - 尽管$4 \times 4$ 的齐次矩阵很复杂,但是却能满足在一个矩阵里同时进行 *线性变换* 和 *位移*.同时,投影到
非坐标轴相关的平面也成为了可能.
    - *投影矩阵* 在实际的渲染管线中做的工作不只是把z复制进w.
      a. 在很多图形系统中,把w=1当作 *depth buffring*[深度缓存]中最远的平面.通常w的范围在[0,1].
      b. 摄像机的 *FOV* (field of view)通常通过 *投影矩阵* 缩放 $x,y$ 值来调整.
** Chapter 7 Polar Coordinate Systems[极坐标系]
   笛卡尔坐标系并不是唯一与空间和位置相关的坐标系.另一个备选的坐标系叫 *极坐标系* [polar coordinate
system].之所以要介绍它,是因为在游戏开发中,某些模块(AI,摄像机)会经常用到.
*** 7.1 2D Polar Space[2D极坐标空间]
    这段会在2D中介绍极坐标的一些基本概念,以对极坐标有一个直观的了解.
**** Locating Points by Using 2D Polar Coordinates[使用2D极坐标来确定点]
    在2D笛卡尔坐标系中,通过 *原点*[origin]来确定坐标系的 *位置*[position],而通过 *原点* 的两个 *轴*[axis]
,确定了坐标系的 *方向*[orientation].
    同样,在2D极坐标系中也有 *原点*,它被用来确定坐标系的中心.一个极坐标系只有一个 *轴*,被叫做 *极坐
标轴*[polar axis],可以把它想象成从原点发出来的射线.习惯上让极坐标轴指向右边(像笛卡尔坐标系里的y轴).
    通过上面的信息,我们可以知道一个极坐标的位置由两个参数确定,一是$r$(半径),一是$\theta$(角度).从而我们可以
用 $(r,\theta)$ 来表示任意在2D极坐标空间中的点的位置.
    以极坐标轴为起点, *逆时针*[counter clockwise] 方向为 *正*[positive], *顺时针* 方向为 *负*[negative],
以此来确定 *角度*[angle] 的大小.
    以点与原点的距离来确定半径 $r$ 的大小.
    总结就是, $r$ 定义了点到原点的距离, $\theta$ 定义了从原点到点的方向.
**** Aliasing[别名]
    对任何极坐标中的点,都可以用无数个成对的极坐标来描述它.这种现象被叫做 *aliasing*.如果两个极坐标
数值不同却表示同一个点,就表明两个互为另一个的 *别名*[aliases].需要注意的是在笛卡尔坐标系中的点是不
存在别名的,因为点和坐标是一一对应的关系.
    在此举一个简单的例子,假设极坐标中存在坐标$(r,\theta)$,则它可能的 *别名* 有$(r,k360^{\circ} + \theta)$,其中 $k$ 是整
数.当 $r<0$ 的时候,被解释成向与轴相反的方向移动.
    再进一步,其实 $+180^{\circ}$ 和 $-180^{\circ}$ 表示的是相同的方向.则有:
    $(r,\theta) = ((-1)^{k}r,(\theta + k180^{\circ})$
    经过上述表达式,我们已经知道了如何在2D极坐标空间中表示任意的点.但是由于 *aliasing* 的存在,为了
避免麻烦,我们必须要一个统一的标准来规范极坐标上的点.于是规定如下:
    $(r,\theta),{r \ge 0,-180^{\circ} < \theta \le 180^{\circ}$ 
    1. 如果 $r=0$ , 则令 $\theta = 0$.
    2. 如果 $r < 0$ , 则取 $-r$ ,再让 $\theta + 180^{\circ}$.
    3. 如果 $\theta \le -180^{\circ}$ , 则让 $\theta + 360^{\circ}$ 直到 $\theta > -180^{\circ}$.
    4. 如果 $\theta > 180^{\circ}$ , 则让 $\theta -360^{\circ}$ 直到 $\theta \le 180^{\circ}$.
**** Converting between Cartesian and Polar Coordinates in 2D[2D下笛卡尔与极坐标的转换]
    2D下极坐标用 $(r,\theta)$ 表示,笛卡尔坐标用 $(x,y)$ 表示.
    _从极坐标转换到笛卡尔坐标很简单,根据三角函数的性质,有:_
    $x = rcos\theta, y = rsin\theta$.
    棘手的是从笛卡尔坐标转换到极坐标.
    首先考虑 $r$ 的转换,通过勾股定理,可得:
    $r = \sqrt{x^{2}+y^{2}}$.
    很明显这里 $r \ge 0$,不需要再考虑对 $r$ 进行 *正则*[canonical]了.
    其次考虑 $\theta$ 的转换,很明显有:
    $\frac{y}{x} = \frac{sin\theta}{cos\theta} = tan\theta, \theta = arctan(y/x)$.
    这里有两个问题,一是 $x \neq 0$ ,二是存在 $arctan\theta,\theta \in [-90^{\circ},+90^{\circ}]$.
    由于 $x = 0$ 时,除法未定义,所以不能运算.而 $y/x$ 由于符号取值问题,会产生四种可能.现在我们来总结下
可能的情况:
    \begin{equation*}
    atan2(y,x) = 
    \begin{cases}
    0, & x=0,y=0, \\
    +90^{\circ}, & x=0, y>0, \\
    -90^{\circ}, & x=0,y<0, \\
    arctan(y/x), & x>0, \\
    arctan(y/x)+180^{\circ}, & x<0,y\ge 0, \\
    arctan(y/x)-180^{\circ}, & x<0,y < 0. \\
    \end{cases}
    \end{equation*}
    需要注意的是, $atan2$ 这个函数的参数是 *反*[reverse]的.另一个要注意的是,在很多 *库*[library]里,
$atan2$ 在原点 $(0,0)$ 是未定义的.但是在本书中,我们定义 $atan2(0,0) = 0$.
    _至此,从笛卡尔坐标到极坐标的转换也已经完成,有:_
    $r = \sqrt{x^{2}+y^{2}},\theta = atan2(y,x)$.
*** 7.2 Why Would Anybody Use Polar Coordinates?[为什么有人要用极坐标]
    其实我们在日常生活中就经常使用极坐标:),比如有人问你的老家在哪儿,你告诉他,在双流的东南方,大概距
双流15公里,其实在这段话里,双流(表示原点),东南方(-45°),15公里(距离r)已经是在运用极坐标了.
    而在游戏里,我们经常在操控摄像头/使用武器等转向目标时,都需要采用极坐标.最厉害的是在追踪方面,通常
使用极坐标都是最好的选择.(先转向再移动,边移动边转向,最终都能直面目标).
    还有一个必须要讲的,采用极坐标而不是笛卡尔坐标的情况: _在一个球面上移动_.参考地球自身,其实我们的
*经度*[longtitude], *纬度*[lantitude] 就是采用的极坐标系,更准确的来说,是某种3D极坐标系- *球型坐标*
[sphere coordinates].
*** 7.3 3D Polar Space[3D极坐标空间]
    3D极坐标系的一个有意思的地方在于,我们知道当坐标从2D到3D,肯定会多一个参数,那么到底多出来的参数是
表示什么?是另一个 *距离* $r$ 还是另一个 *方向* $\theta$ ?
    事实是,3D极坐标空间有两种形态,
    一种是 *圆柱型坐标*[cylindrical coordinates],多出来的参数是另一个距离$r$.表示为:
    $(r,\theta,z)$
    另一种是 *球型坐标*[spherical coordinates],多出来的参数是另一个角度$\theta$.表示为:
    $(r,\theta,\phi)$
**** Cylindrical Coordinates[圆柱型坐标]
    要构造一个圆柱型坐标,分两步:
    1.) 构造一个2D极坐标,形成一个平面.
    2.) 过2D平面的原点作一条轴垂直于平面,命名为z轴.
    这样我们就可以将任意圆柱空间内的点表示为 $(r,\theta,z)$.而圆柱坐标系与笛卡尔坐标系的转换也非常简单.
参考之前2D的转换,再加上在z轴的表示上,两者是相同的,因而很简单.
**** Spherical Coordinates[球型坐标]
    相较于圆柱型坐标,球型坐标更为常见.同样的,我们来考虑如何构建一个球型坐标系.
    1.) 想象自己站在原点,面对水平方向上的极坐标轴,垂直方向上的极坐标轴是从你的脚到你的头的方向.
    再将你的右手臂指向天空,与垂直方向的轴平行.
    2.) 逆/顺时针旋转 $\theta$.
    3.) 将你的右手臂向下旋转 $\phi$.
    4.) 从原点沿着方向移动距离$r$.
    水平方向上的角 $\theta$ 被叫做 *定向角*[azimuth], $\phi$ 被叫做 *天顶角*[zenith].
**** Some Polar Conventions Useful in 3D Virtual Worlds[虚拟3D世界中一些有用的极坐标设定]
    前面提到的球型坐标系是传统的右手坐标系统.在此系统下笛卡尔坐标系与球型坐标系的转换非常的简洁.然
而,对真正在游戏行业工作的人来说,这个系统带来的麻烦远大于给予的好处:
    - 默认的水平方向 $\theta = 0$ 指向的是 $+x$ .因为在大多数人的眼中,  *默认* 水平方向并不会让人联想
到 *右手*或者 *东*.
    - 从某些方面来看,使用 $\phi$ 并不合适.从2D扩展到3D时第一个要考虑的就是新增的 $\phi$ 的初始值问
题,而让人尴尬的是令 $\phi = 0$ 将导致一个问题 - *Gimbal lock*[万向节死锁].相反,我们让这个点在2D平面
中表示为$(r,\theta,90^{\circ})$.
    - $\theta$ 和$\phi$ 需要一定的时间去适应.$r$ 还有,至少能直观的让人知道表示 *半径*[radius].
    - 如果 *球型坐标* 的前两个角能和 *欧拉角*[Euler angless]一样的话就爽了. *欧拉角* 主要用来表示3D中
的方向.(第八章就知道欧拉角是什么了:))
    - 这是个 *右手坐标系*,而我们在这里使用 *左手坐标系*.(异端啊)

    在我们定义的 *球型坐标系* 里, $r$ 继续保留原意使用.至于另外两个角则需要重新命名和调整.
    水平方向上的角被重命名为 $h$ , *heading*[头],默认为0时表示方向为 *forward* 或者是 *to the north*.
考虑到我们采用的是 *左手坐标系*, $h$ 对应的是笛卡尔坐标系的 $+z$ 轴.同样原因,选取 *顺时针*[clockwise]
为旋转正方向.
    垂直方向上的角被重命名为 $p$, *pitch*[倾斜角],主要用于测量向上/向下看的角度的大小.
    默认当 $pitch = 0$ 时表示指向水平方向.默认的正方向时 *向下*[downward]的,表示在测量 *偏角*
[angle of declination].向下为正可能让人觉得有点不符合直觉,但是确是与左手坐标系的规则吻合的.
**** Aliasing of Spherical Coordinates[球型坐标的别名]
    在2D极坐标的时候我们就讨论过坐标 *别名*[aliasing]问题,一个空间中的点可以由多个坐标来表示.在3D
中一样有这个问题.
    第一个肯定能解决别名的方法就是给每个轴加一个 $\times 360^{\circ}$.很明显这不是一个优雅的解决方案.
    另外两个解决方案很有意思,因为它们是由坐标的互相依赖引起的.换句话说就是, $r$ 的含义是通过角的值来
确定的.这种依赖关系造成了 *别名* 和 *奇点*[fn:singularity]:
    - 在2D中出现 *别名* 时,可以通过让 $r$ 取负和调整 $\theta$ 值来解决.同样在3D中我们也可以通过让奇数值 $\times$
180° 来表示反转 *heading*,再对 *pitch* 取负.
    - 在2D中奇点出现在 $r=0$ 时,因为这个时候角坐标无法确定值.同样在3D中,当 $r=0$ 时两个角也无法确
定值.
    由于 $r$ 的变化取决于角的值,所以球型坐标系统一样会产生 *别名* 问题.然而更坑的是,它还有遇到另外一个
*别名* 问题.由于 *pitch* 角围绕轴的旋转取决于 *heading* 角,这就造成了另一种 *混淆* 和 *奇点*.
    - 就算排除掉各自独立的角的别名,不同的 *heading* 和 *pitch* 值也能得到相同的 *方向*[direction].
      $(h,p)$ 可以被表示为 $(h \pm 180^{\circ}, 180^{\circ} - p)$.
    - *奇点* 出现在 *pitch* 等于 $\pm 90^{\circ}$ 的时候.这种情况被叫做 *Gimbal lock*[万向节死锁],方向总是完全垂
直并且 *heading* 角已经 *不相关*[irrelevant].(但是这个问题我们还是等到第八章再说:)).
    在2D极坐标的时候我们就定义了一个 *正则球型坐标*[canonical spherical coordinates].在3D球型坐标中,
$r,h$ 还是同之前定义一样,而 *pitch* 则添加了两个限制条件.
    第一是 *pitch* 的值限定在 $[-90^{\circ},+90^{\circ}]$.
    第二是当出现 *Gimbal lock* 的时候, 由于 *pitch* 取到了极值, *heading* 值将变得 *不相关*,所以这种
情况下我们强制让 $h=0$.
    现在我们列出 _满足标准球型坐标的情况_:
    $r\ge 0$
    $-180^{\circ} < h \le 180^{\circ}$
    $-90^{\circ} \le p \le 90^{\circ}$
    $r=0, \Rightarrow  h=p=0$
    $|p| = 90^{\circ} \Rightarrow h=0$
    下面是 _如何将一个非标准坐标转换到标准坐标的算法_:
    1. if $r=0$,then assign $h=p=0$.
    2. if $r<0$,then negate $r$,add $180^{\circ}$ to $h$ ,and negate $p$.
    3. if $p < -90^{\circ}$,then add $360^{\circ}$ to $p$ until $p \ge -90^{\circ}$.
    4. if $p > 270^{\circ}$,then subtract $360^{\circ}$ unitl $p \le 270^{\circ}$.
    5. if $p > 90^{\circ}$,then add $180^{\circ}$ to $h$ and set $p = 180^{\circ} -p$ .
    6. if $h \le -180^{\circ}$,then add $360^{\circ}$ to $h$ until $h > -180^{\circ}$ .
    7. if $h > 180^{\circ}$,then subtract $360^{\circ}$ from $h$ until $h \le 180^{\circ}$ .
**** Converting between Spherical and Cartesian Coordinates[球型坐标与笛卡尔坐标的相互转换]
1.   从 _球形坐标系转换到笛卡尔坐标系_,
    先讨论传统意义上的使用 *右手坐标系* 的情况.
    我们首先要考虑的是 _已知参数:$(r,\theta,\phi)$_.一个是长度,两个是角度.
    而真正的问题在于如何表示 $(x,y,z)$.三个参数都是长度.
    根据勾股定理,一个很明显的公式是 $\sqrt{x^{2}+y^{2}+z^{2}} = r$,在此考虑将水平平面上的值 $\sqrt{x^{2}+y^{2}$ 
用 $d$ 表示,则有 $d = \sqrt{x^{2}+y^{2}}$.
    再根据两个角度 $(\theta,\phi)$ 来表示 $(x,y,z)$ 的值,有:
    $z/r = cos\phi, z = rcos\phi$ .
    剩下的就是如何计算 $x,y$ 了.现在先考虑 $\phi = 90^{\circ}$ 的情况.在这种情况下,3D极坐标空间就变成了一个
2D极坐标空间.假设 $x^{'},y^{'}$ 分别为$x,y$ 在 $\phi = 90^{\circ},d=r$ 下的结果,那么我们有:
    $x^{'} = rcos\theta,y^{'} = rsin\theta$.

    根据相似三角形的性质,有 $x/x^{'} = y/y^{'} = d/r$,而同时 $d/r = sin\phi$ .由此可得:
    *右手坐标系* 下, $(r,\theta,\phi)$
    $\boldsymbol{x = rsin \phi cos \theta, y = rsin \phi sin\theta, z = rcos \phi}$.

    *左手坐标系* 下,
    $\boldsymbol{x = r cos(p) sin(h), y = -rsin(p), z = rcos(p)cos(h)}$.
    _于是,当从球形坐标系转换到笛卡尔坐标系时,有:_
    $\boldsymbol{(x,y,z) \Rightarrow x = r cos(p) sin(h), y = -rsin(p), z = rcos(p)cos(h)}$

2.  从 _笛卡尔坐标到球型坐标系_,
    在2D极坐标系中,$r = \sqrt{x^{2}+y^{2}+z^{2}}$.
    在 $r=0$ 时,奇点位于原点,算是一种特殊情况.
    至于 $h$,使用atan2可以直接得出:
    $h = atan2(x,z)$.
    由之前的等式可知, 
    $y = -rsin(p),-y/r = sin(p),p = arcsin(-y/r)$.

    _于是,当从笛卡尔坐标转换到球型坐标时,有:_
    $\boldsymbol{(r,h,p) \Rightarrow r = \sqrt{x^{2}+y^{2}+z^{2}}, h = atan2(x,z),p = arcsin(-y/r)}$.
*** 7.4 Using Polar Coordinates to Specify Vectors[使用极坐标系来确定向量]
    我们已经知道了如何在极坐标系中描述一个 *点*,也知道怎么在笛卡尔坐标系中描述一个 *向量*.同样,我
们也可以在极坐标系中描述一个向量.极坐标具有的两种类型的参数, *方向* 和 *长度*,原本就是向量自身的
属性.
    所以说,实际上极坐标所做的,就是直接描绘向量.而笛卡尔坐标系中反而采用了一种间接的方法来表示向
量.当我们讨论如何使用极坐标时,实际生活中不知道已经使用了多少次."在你的右前方5米的地方",诸如此类.
    同样我们也已经知道如何在数学上完成向量在笛卡尔坐标和极坐标的转换.因为转换 *点* 的技巧可以原封
不动用在 *向量* 身上.
** Chapter 8 Rotation in Three Dimensions[三维下的旋转]
   本章的主题是 _如何在3D空间中描述物体 *定向*[orientation]_,顺便也会讨论下3D空间中的 *旋转*[rotation]
和 *角位移*[angular displacement].
   讨论的核心在于 1.) *矩阵*[matrix] 2.) *欧拉角*[Euler angle] 3.) *四元数*[quaternion],另有两种少见的形
式, 1.) *轴角*[axis-angle] 2.) *指数映射*[exponential map].
   对每个方法我们都会准确的定义它的具体表现,并且讨论各自的特色,优点和缺点.
   *注意*,本章将频繁的涉及到概念 *object space* 和 *upright space*.
*** 8.1 What Exactly is "Orientation"[什么是定向?]
    在开始讨论如何描述3D中的 *定向*[Orientation] 之前,我们先要给它一个准确的定义.相较于以下几个术语:
    - *定向*[direction]
    - *角位移*[angular displacement]
    - *旋转*[rotation]
    直观上讲,一个物体的 *定向* 就是告诉我们物体所面对的 *方向*.然而, *定向* 和 *方向* 并不能划等号.
    举例来说,一个向量有 *方向*,却没有 *定向*.区别在于当向量指向一个方向时,你 *扭转*[twist]它,它不会
发生任何改变.因为它没有 *厚度*[thickness] 或者是 *宽度*[dimension].
    相反的是, 假设一个实际物体,比如 *喷气式飞机*[jet],面对一个方向.如果你 *扭转*[twist] 一个喷气式飞机,
它的 *定向* 就会发生改变.
    最基本的区别在于确定一个 *方向* 可以只用 _两个参数_ (想想上一章的 *球型坐标*),而 *定向* 却需要 
_至少三个参数_,其中一个参数就是 *欧拉角*[Euler angle].
    在前面我们就知道了用绝对坐标来描述物体位置是不可能的,只有在有参考系时才能确定物体位置.
    如同我们描述某个 
    *位置*[position],
    实质上是在描述从某个给定参考点(比如原点)到已知点的 *位移*[translation].

    *定向*[orientation],
    其实就是已知定向(通常被叫做 *单位定向*[identity orientation] 或者 *源定向*[home orientation])的
*旋转* 来描述的.
    而 _旋转的量_ 被叫做 *角位移*[angular translation].换句话说,数学上描述 *定向* 就是在描述 *角位移*.
    在本书中,我们对 *定向*, *角位移*, *旋转* 会做细微的区分.把 *角位移* 当作一个函数(接受一个输入,提
供一个输出)来看是很有用的.比如说, 通过 *角位移* 从旧定向到新定向,或从 *upright space* 到 *object space*.
    _一个关于角位移的例子_,"绕z轴旋转90°".
    然而,我们经常遇到不适合用 *角位移* 的 _输入/输出_ 这种形式,反而是 _父/子_ 关系更容易描述的情况,在
这个时候我们就倾向于使用 *定向* 来描述.
    _一个关于定向的例子_,"站直,然后面向东方".
    *定向* 和 *角位移* 的区别就像是点和向量的区别,两个术语都是在数学上等价而概念上不同.在这两个例子
中, *定向* 和 *点*,都是在描述 _静态结果_,而 *角位移* 和 *向量*,却是在描述 _动态过程_.
*** 8.2 Matrix Form[矩阵形式]
    一个描述3D坐标空间的 *定向*[orientation1] 的方法是说明坐标系中基向量(+x,+y,+z轴).但事实上我们不
必计算这些基向量,因为通过定义,无论坐标空间处于什么 *定向*,它的基向量都是$[1,0,0],[0,1,0],[0,0,1]$.
所以需要通过其他坐标空间来表示基向量.由此,我们建立了两个坐标空间的 *相对定向*[relative orientation].

    当这些基向量用来生成一个 $3 \times 3$ 矩阵的时候, *定向* 可以通过 *矩阵形式*[matrix form]表示.另一种说
法是我们可以通过一个 _将一个向量从一坐标系转到另一坐标系_ 的 *旋转矩阵*[rotation matrix]来表示两个
坐标系的 *相对定向*.
**** Which Matrix?[什么矩阵?]
    我们知道怎么使用矩阵来将点从一个坐标系转换到另一个坐标系.

[[file:Image/Figure 8.3.png]]
    观察上图,右上角的矩阵表明了从喷气式飞机的 *object space* 到 *upright space* 的旋转.指定的每个行
向量表示的是在 *upright space* 中的 *object axes*[对象轴]的位置.
    同时这又是个旋转矩阵,意味着我们可以让 *object space* 中向量的坐标转换成 *upright space* 的坐标
表示.
    问题在于,为什么包含 *body axes* 的矩阵使用 *upright space* 来表示,而不是让 *upright axes* 在 
*object-space coordinates* 中表示?或者说,为什么我们选择一个将向量从 *object space* 转换到 *upright-*
*space* 的旋转矩阵,而不选择从 *upright space* 到 *object space* 的旋转矩阵.
    从数学上来说这个问题有点可笑,因为旋转矩阵是 *正交*[otrhogonal]的,所以它的 *转置*[transpose] 和它
的 *逆*[inverse]是一回事.所以说,这两者的区别根本无关紧要.
    但实际在我们看来,这却很重要.目前的问题是你能否第一次就写出一些直观可读同时还能够运行的代码,还
是这段代码需要大量的时间来辨认,抑或一些大家不言自明的常识而你却一无所知.在此说一句关于 *upright-*
*space* 的题外话,考虑到实际中从数学到具体代码(关于坐标空间转换),同时考虑到我们作为程序员对旋转矩
阵的认知,我们并不期望每个人都能同意我们的断言,但是希望每个读者至少在考虑这些问题时能感受到它们的
价值.
    对每一个有矩阵的数学库而言($3 \times 3$ 矩阵就能表示任意变换,$4 \times 4$ 矩阵可以额外做投影,$4 \times 3$ 矩阵可以
额外做平移),这些运算天生就是在 _输入坐标空间,输出坐标空间_.在矩阵乘法中就暗示了这点.如果你想要反过
来从输出到输入,就必须要掌握矩阵的 *逆* 运算.
    从程序员的角度来看,使用 *通用变换矩阵类*[generic transform class]来描述某个物体的定向可以说是
常识,毕竟旋转只是变换的一种. *接口*[interface]仍然表达的是 _输入源空间,输出目标空间_.但是在我们的经
验中,用的最多的却是以下两种矩阵运算:
    - 让一个 *object-space* 中的向量在 *upright coordinates* 中表示.
    - 让一个 *upright-space* 中的向量在 *object coordinates* 中表示.
    从我们的经验来看,不存在两个里哪个使用明显更频繁的情况,所以两种情况我们都需要同时考虑.但是无论
怎么样,作为一个程序员,我们在考虑的运算其实都是 *object space* 和 *upright space* 的转换,而不是 *source-*
*space*[源空间]和 *destination space*[目标空间].
    现在再来看看 *orientation*[定向] 和 *angular displacement*[角位移]的区别.当你的目标是创造一个表示
角位移的矩阵(比如"绕x轴旋转30°"),那你想的多半和上面的两个矩阵运算不一样,并且使用隐含了方向变换的
*通用变换矩阵* 完全没问题.所以在这个问题上,没有讨论必要.现在我们关注的是一些物体中作为状态变量的
*定向*.
    现在假设我们采用普遍的方案---使用 *通用变换矩阵* 来保存 *定向*.现在我们就来看看这种普遍方案是怎
么影响我们的:
    - _Rotate some vector rom object space to upright space_ is translated into code as multiplication by
      the matrix.
    - _Rotate a vector from upright space to object space_ is translated into code as multiplication by the
      inverse(or transpose) of the matrix.
    对高阶程序员来说当然不成问题,但是从我们的经验来看,记忆上述运算简直要了初级程序员的老命.这其实
反映的是接口的设计问题,如果我们设计一个专用的 $3 \times 3$ 旋转矩阵来保存 *定向* 会好很多.因为采用了更高
一层的抽象来表示旋转简化了问题,唯一要考虑的只是确定一个命名规范来让大家产生共识.事实上,在实际编程
中, *multiply a vector* 或者 *invert this matrix* 这些操作并没有那么有用(因为更多的程序员不需要了解这
些数学细节),你需要告诉他们的更应该是 *objectToUpright* 或者 *uprightToObject* 这种运算.
**** Direction Cosines Matrix[方向余弦矩阵]
    *direction cosines matrix*[方向余弦矩阵] 和 *rotation matrix*[旋转矩阵]是一回事.这只是一种特殊的解
释(或者构造)矩阵的方法,只是很有趣和教育意义,我们让我们来看看嘿嘿:).
    旋转矩阵的每个元素都等于某个空间的轴和另一轴空间的轴的点乘.
    更为普遍的是,现在假设某个坐标空间有正交的单位向量$\boldsymbol{p,q,r}$ ,同时另一个坐标空间也有(不相等的)正交
的单位向量$\boldsymbol{p^{'},q^{'},r^{'}}$.
    旋转矩阵通过构造成对的基向量的角的余弦值来完成行向量从第一个坐标空间到第二个坐标空间的旋转.当
然每个单位向量的点乘是等于它们角的余弦值的.所以有:
\begin{equation*}
v
\begin{bmatrix}
p \cdot p^{'} & q \cdot p^{'} & r \cdot p^{'} \\
p \cdot q^{'} & q \cdot q^{'} & r \cdot q^{'} \\
p \cdot r^{'} & q \cdot r^{'} & r \cdot r^{'} \\
\end{bmatrix}
= v^{'}.
\end{equation*}
    不要忘了$p,q,r,p^{'},q^{'},r^{'}$ 都是 *单位向量*[unit vector],同时还有点乘的几何意义:
    $a \cdot b = |a||b|cos\theta$,在这里由于是单位向量,则有: $a \cdot b = |a||b|cos\theta = cos\theta$.
    假设我们的轴用第一个坐标空间的基向量来描述,则$p,q,r$ 分别被表示为 $[1,0,0],[0,1,0],[0,0,1]$.而
第二个坐标空间的基向量$p^{'},q^{'},r^{'}$ 则是任意坐标.当我们将其代入之前的等式,则有:
 \begin{equation*}
\begin{bmatrix}
[1,0,0] \cdot p^{'} & [0,1,0] \cdot p^{'} & [0,0,1] \cdot p^{'} \\
[1,0,0] \cdot q^{'} & [0,1,0] \cdot q^{'} & [0,0,1] \cdot q^{'} \\
[1,0,0] \cdot r^{'} & [0,1,0] \cdot r^{'} & [0,0,1] \cdot r^{'} \\
\end{bmatrix}=
\begin{bmatrix}
p_{x}^{'} & p_{y}^{'} & p_{z}^{'} \\
q_{x}^{'} & q_{y}^{'} & q_{z}^{'} \\
r_{x}^{'} & r_{y}^{'} & r_{z}^{'} \\
\end{bmatrix}=
\begin{bmatrix}
-p^{'}- \\
-q^{'}- \\
-r^{'}- \\
\end{bmatrix}
\end{equation*}
    换句话说, _通过使用输入坐标空间的坐标,旋转矩阵的行向量就是输出坐标空间的基向量_.这个事实不仅
对旋转矩阵有效,对所有的变换矩阵都有效.这就是所有的变换矩阵都能工作的核心原因.
    现在我们来考虑另一种状况,即使用第二个坐标空间(输出空间).这个时候,$p,q,r$ 是任意的.
\begin{equation*}
\begin{bmatrix}
[1,0,0] \cdot p & [0,1,0] \cdot p & [0,0,1] \cdot p \\
[1,0,0] \cdot q & [0,1,0] \cdot q & [0,0,1] \cdot q \\
[1,0,0] \cdot r & [0,1,0] \cdot r & [0,0,1] \cdot r \\
\end{bmatrix}=
\begin{bmatrix}
p_{x} & q_{x} & r_{x} \\
p_{y} & q_{y} & r_{y} \\
p_{z} & q_{z} & r_{z} \\
\end{bmatrix}=
\begin{bmatrix}
| & | & | \\
p^{T}& q^{T} & r^{T} \\
| & | & | \\
\end{bmatrix}
\end{equation*}
   这说明了, _通过使用输出坐标空间的坐标,旋转矩阵的列向量就是输入坐标空间的基向量_.当然这个事实不
是对所有的矩阵变换都有用,而是只有 *正交矩阵* 才满足.
**** Advantages of Matrix Form[矩阵形式的优点]
    矩阵以一种非常直接的形式来描述 *定向*,这种直接带来了如下优点:
    - _可以立即进行向量旋转_.
      Rotation of vectors is immediately available.
    - _矩阵的形式被图形API调用_.
      Format used by graphics APIs.
    - _多个角位移拼接_.
      Concatenation of multiple angular displacements.
    - _矩阵的逆_.
      Matrix inversion.
**** Disadvantages of Matrix Form[矩阵形式的缺点]
    使用矩阵来表示定向的缺点在于太浪费内存.一个矩阵使用9个数来表示一个定向.而实际上一个定向只需要
3个数字就能确定.
     - _矩阵占用更多内存_.
       Matrices take more memory.
     - _矩阵对人而言难于使用_.
       Dificult for humans to use.
     - _矩阵可能是病态的_.
       Matrices can be ill-formed.
       由于浮点数的精度限制,大量矩阵乘法最终可能导致病态矩阵,这种现象被叫做 *矩阵蠕变*[matrix creep].
**** Summary of Matrix Form[总结]
    - 矩阵是表达 *定向*[orientation]的强力方法:我们能明确的把当前空间的基向量在其他坐标空间表述出来.
    - 术语 *direction cosines matrix*[方向余弦矩阵]暗示了旋转矩阵中的每个元素都等于输入空间的基向量
与输出空间的基向量的 *点积*.
      对所有矩阵变换来说,矩阵的 *行*[row] 向量是 _输入空间的基向量在输出空间的坐标_.
      而旋转矩阵的 *列*[column]向量是 _输出空间的基向量在输入空间的坐标_,这种情况只有在旋转矩阵是
*正交* 时才满足.
    - 矩阵形式表达 *定向* 的主要用处在于,它允许我们在不同的坐标空间之间旋转向量.
    - 现代图形API使用矩阵来描述 *定向*.
    - 我们可以使用矩阵乘法嵌套多个矩阵来得到一个单一矩阵.
    - 矩阵的 *逆* 提供了一种得到"相反"的角位移的机制.
    - 矩阵对比其他方法,会多占用2到3倍的内存.这样造成的资源浪费是一个问题.
    - 矩阵对人类来说不够直观.
    - 并非所有的矩阵都能描述方位.有些可能包含 *mirroring* 或者 *skew*.从外部数据源得到坏数据或者
*矩阵蠕变*[matrix creep]都会导致 *病态矩阵*[ill-formed matrix].
*** 8.3 Euler Angles[欧拉角]
**** What Are Euler Angles?[欧拉角是什么]
    *欧拉角* 的基本思想是将 *角位移* 看作是分别绕三个互相垂直的轴旋转所组成的序列.听起来可能很拗口,
但实际上很直观.(事实上它的主要优势就在于人类更容易理解).
    所以现在来看, *欧拉角* 将 *定向* 描述为 _分别绕三个互相垂直的轴作旋转的序列_.具体是以什么顺序绕
哪个轴做旋转?其实都可以,不过为了统一,书中用的也是最常见的欧拉角命名顺序是 *heading-pitch-bank*.所
以,一个 *定向* 可以由三个欧拉角定义:$(heading,pitch,bank)$.
    考虑到本书采用的是 *左手坐标系* ,同时拥有了 *heading,pitch,bank* 三个角,我们现在可以通过使用
欧拉角,四步来确定一个 *定向*:
    1.) 从 *标准定向*[identity orientation]开始,也就是一个与 *upright axes* 对齐的 *object-space axes*.
    [[file:image/Figure 8.4.png]]

    2.) 执行 *heading* 旋转,绕y轴旋转,正向是顺时针(向右).
    [[file:image/Figure 8.5.png]]

    3.) 在执行完 *heading* 旋转后, 执行 *pitch* 旋转,绕x轴旋转,注意这里的x轴是指 *object space* 的x轴,
正向是顺时针(向下).
    [[file:image/Figure 8.6.png]]

    4.)执行完 *pitch* 后,再执行 *bank* 旋转,绕z轴旋转,同样是 *object space* 的z轴,从z轴的正方向看过来,
正向依然是顺时针.
    [[file:image/Figure 8.7.png]]
**** Other Euler Angle Conventions[其他关于欧拉角的约定]
    前面所说的 *heading-pitch-bank* 并不是唯一能表示欧拉角的系统,它们中的区别有些纯粹是命名不同,有
些确实有区别.
    首先,存在一个命名问题.在航空航天领域最常见的命名是 *yaw-pitch-roll* 方法. *roll* 和 *bank* 是完全
等价的,而 *yaw* 和 *heading* 是相似的(这个微小的区别让我们更倾向于使用 *heading*,但是差别不大).所
以本质上来说, *yaw-pitch-roll* 和 *heading-pitch-bank* 是一个系统.
    还有其他一些对应的命名,如:
    *heading* -> *azimuth*, *pitch* -> *elevation* / *attitude*, *bank* -> *tilt* / *twist*.
    当然还有一些数学家使用希腊字母来表示,然而这些字母我并不想打:(
    *The fixed-axis system*[定轴系统]与欧拉角很相似.在欧拉角系统中,旋转是发生在 *body axes* 的,轴在每
次旋转后都会变化.因此,举个例,对 *bank* 角来说, *physical axis* 总是纵向的 *body space* 的那个轴.但是
在 *upright space* 它却可以是任意轴.而在 *fixed-axis system* 中刚好相反,旋转是发生在 *upright axes*
的.但最终还是证明了 *Euler angle system* 和 *fixed-axis system* 是等价的.
    让我们先假设有一个 *heading*-h 和一个 *pitch*-p,(暂不考虑 *bank*).
    根据欧拉角的规则,我们首先对垂直轴(y轴)旋转角度h,再旋转 *object space* 中的横轴(x轴),角度为p.
    根据固定轴的规则,我们可以用 _相反的顺序_ 来完成同样的步骤.首先我们旋转 *upright-space* 的x轴旋
转角度p,再旋转 *upright space* 中的y轴,角度为h.
    在计算机上我们采用固定轴来完成向量的旋转,但是固定轴只是 *extrinsic*[外在的],欧拉角才是 *intrinsic*
[本质的].
    注意,欧拉角是以 *body axes* 来作旋转的,所以它轴的旋转顺序是以前面旋转的角度来决定的.而在固定轴
系统中,旋转的轴总是 *upright axes*,两者是等价的,只是旋转顺序上刚好相反.
    现在我们来谈谈 *yaw*.大量的 *航天*[aeronautical]术语继承自 *航海*[nautical]术语,在航海学中, *yaw*
最开始和 *heading* 具有相同的含义,都是关于绝对角度和它的变化.然而在航天等领域, *yaw* 和 *heading*
却不再相同.一个 *yawing motion*[横摆运动]是围绕 *对象*[object]的y轴的旋转,而在 *heading* 里却是围绕
*upright* 的y轴的旋转.图8.8描述了两者的区别:
    [[file:image/Figure 8.8.png]]
    无论怎么样定义你的轴,都要记住第一个旋转的总是垂直的那个轴,第二个则是物体侧轴,最后才是物体纵轴.
(偏航 -> 俯仰 -> 倾斜).
**** Advantages of Euler Angles[欧拉角的优点]
    欧拉角只用3个参数就能确定 *定向*,而且这些参数还是角度.
    - _欧拉角易于使用_.
      Euler angles are easy for humans to use.
    - _欧拉角拥有最简洁的表现方式_.
      Euler angles use the smallest possible representation.
    - _任意三个数都是合法的_.
      Any set of three numbers is valid.
**** Disadvantages of Euler Angles[欧拉角的缺点]
    欧拉角的缺点主要有:
    - _定向的表达方式不唯一_.
      The representation for a given orientation is not unique.
    - _两个角度间求 *插值*[interpolating] 非常困难_.
      Interpolating between two orientations is problematic.
    现在来仔细说说这些问题.首先是 *别名*[aliasing]造成的表达法方式不唯一,原因很简单,只要是采用角度/
弧度制的方案都必然会造成这个问题.
    第一种情况是,在将一个角度加上360°的倍数时,就会遇到别名问题.
    第二种情况则更麻烦,由于三个角度并不是互相独立的,例如, 向下 *俯仰*[pitching]135°等价于先 *偏航*
[heading]180°-> 向下 *俯仰* 45° -> *倾斜*[bank]180°.
    在 *球型坐标系* 中解决 *别名* 问题采用的方法是建立一个 *规范集*[canonical set],任何给定的点都会表
示成一个唯一的坐标.在欧拉角问题上,我们采用同样的方式来解决问题.一种普遍的方式是规定,
    $heading,roll \in (-180^{\circ},180^{\circ}],pitch \in [-90^{\circ},90^{\circ}]$.
    而欧拉角中最著名(也是最烦人)的别名问题来自这个例子:
    head right 45° -> pitch down 90° $\leftrightarrow$ pitch down 90° -> banking 45°.
    事实上当一旦让 $\pm 90^{\circ}$ 作为 *pitch*[俯仰]的角度,它就只能绕垂直轴旋转.第二次旋转角为 $\pm 90^{\circ}$,会造成
第一次和第三次的旋转轴相同,这种现象被叫做 *Gimbal Lock*[万向锁].为了解决这个问题,我们将在 *万向锁*
情况下的绕垂直轴的旋转都交由 *heading*[偏航]完成,也就是说,在$pitch = \pm 90^{\circ}$ 的情况下,令 $bank = 0$.
    这样,我们就完成了欧拉角的 *规范集*:
    $-180^{\circ} < h \le 180^{\circ}$
    $-90^{\circ} \le h \le 90^{\circ}$
    $-180^{\circ} < b \le 180^{\circ}$
    $p = \pm 90^{\circ} \Rightarrow b = 0$.
    当写代码时接受一个欧拉角参数时,最好保证输入参数的范围不受限制,但是在返回角的值的时候,最佳实践
仍然是返回一个规范集内的欧拉角.
    一个常见的误解是: _由于万向锁,某些定向无法用欧拉角来描述_,但是事实上,对于描述定向来说,任何3d中
的定向都能用欧拉角来描述,并且在欧拉角的规范集里是唯一的.
    所以对仅 *描述*[describing]定向来说, *别名* 不算太大的问题.那么大问题是什么?当我们想在两个定向
$\boldsymbol{R_{0},R_{1}}$ 中插值时.换句话说,对一个给定参数 $t,0 \le t \le 1$,计算临时方位 $\boldsymbol{R_{t}}$,当t从0变化到1时, $\boldsymbol{R_{t}}$ 也平滑
的从 $\boldsymbol{R_{0}}$ 过渡到 $\boldsymbol{R_{1}}$.这在角色动画和摄像机控制中是极其有用的技术.
    这个问题的简单解法是分别对三个角使用 *standard linear interpolation formula*[标准线性插值公式]:
    $\triangle\theta = \theta_{1} - \theta_{0}$,
    $\theta_{1} = \theta_{0} + t\triangle\theta$
    稍微思考一下你就会发现这样有问题.
    首先,如果不使用规范集,我们就会有很多很大的角.比如,假设 heading of $\boldsymbol{R_{0}}$ 表示为 $h_{0}$,为 $720^{\circ}$,假设 $h_{1}$
为 $45^{\circ}$,实际上 $h_{0}$ 到 $h_{1}$ 只有$45^{\circ}$ 的距离,但是根据公式我们却要绕接近两圈.显然要解决这个问题,我们肯定
要使用规范集来规范度数.
    假设我们总是在两个欧拉角的规范集内作插值,或者说在插值函数外就将这些角转换为规范集内的欧拉角(
将角度限制在 $(-180^{\circ},+180^{\circ}]$ 很简单,但是要将pitch角限制在 $[-90^{\circ},+90^{\circ}]$ 却是个挑战).
    然而,就算是使用欧拉角的规范集,也不能完全解决问题.第二个插值问题是由旋转角度的周期性引起的,假设
$h_{0} = -170^{\circ},h_{1} = 170^{\circ}$.注意这些都是规范后的heading值,都满足范围 $(-180^{\circ},+180^{\circ}]$,如下图:
    [[file:image/Figure 8.10.png]]
    显然,就算是规范后的角度,它仍然会移动 $340^{\circ}$ 而不是 $20^{\circ}$.解决这个问题的方法是找到插值之间的最短弧.
于是我们有了如下等式:
    $wrapPi(x) = x - 360^{\circ} \lfloor (x+180^{\circ})/360^{\circ} \rfloor$
    这里的 $\lfloor . \rfloor$ 表示的是 *取整* 函数.
    wrapPi函数在每个游戏程序员的工具箱都留有一席之地.它简单而聪明的解决了角的周期性引发的问题.现
在我们有了新的解决方案:
    $\triangle\theta = wrapPi(\theta_{1} - \theta_{0})$,
    $\theta_{1} = \theta_{0} + t\triangle\theta$.
    就算使用了这个方案,仍然无法解决万向锁的问题.物体会突然飘起来或者是挂在某个地方.根本原因是在插
值过程中角速度不是恒定的.
    关于欧拉角的插值问题,前两个虽然很麻烦但并不是无解的,通过 *欧拉角的规范集*[Canonical Euler angles]
和 *wrapPi* 能解决问题.然而 *万向锁*[Gimbal lock]却是个底层问题.任何一个用三个参数表达 *定向* 的方
法都无法绕过这个问题,这是它的固有缺陷.
    于是,我们引入了新的工具, *四元数*[quaternions].
**** Summary of Euler Angles[小结]
    - 欧拉角使用三个角来保存 *定向*[orientation].这三个角是分别围绕三个 *object-space* 的轴有序旋转的
旋转量.
    - 最常见的欧拉角系统是 *heading-pitch-bank*[偏航-俯仰-倾斜]系统.
    - 在 *fixed-axis system*[定轴系统]中,旋转是围绕 *upright axes* 而不是 *body axes*.定轴系统和欧拉角
是等价的,只是两者的旋转顺序相反.
    - 在大多数情况下,欧拉角都比其他表达 *定向* 的方法更直观.
    - 欧拉角在保存 *定向* 时占用最少的内存,并且相较 *四元数* 更容易 *压缩*[compressed].
    - 任何三个数都能组成一个有意义的欧拉角.
    - 旋转的周期性和旋转的不独立性会导致欧拉角的 *别名*[aliasing]问题.
    - 使用欧拉角的 *规范集*[canonical set]能化简角度.
    - *万向锁*[Gimbal lock]发生在 $pitch = \pm 90^{\circ}$ 时,因为在这个时候 *heading* 和 *bank* 都只是在绕垂
直的那个轴旋转.
    - _任何_ 定向都可以用欧拉角来表示,并且在欧拉角的规范集里是唯一的.
    - 在实际编程中 *wrapPi* 使用非常的频繁.把它加入到你的工具箱里吧!
    - *别名*[aliasing]问题虽然烦人但是有解决方案,而万向锁却是一个没有简单解决方案的底层问题.万向锁
问题的原因在于 *定向* 的参数空间是 *不连续*[discontinuity]的.
*** 8.4 Axis-Angle and Exponential Map Representations[轴-角和指数映射]
    *Euler's rotation theorem*[欧拉旋转定理]:
    在三维空间里,假设一个 *刚体*[rigid body]在做一个位移的时候,刚体内部至少有一点固定不动,则此位移等
价于一个绕着包含那个固定点的固定轴的旋转.
    对比欧拉角,欧拉角需要三个旋转量来表示一个 *定向*,因为我们被限制在了绕坐标轴旋转,而现在我们不再
限定与绕坐标轴旋转了,现在可以绕任意轴旋转.当我们选择任意轴做旋转的时候,可能会找到只用一次旋转就搞
定的,而这个轴我们会在后面证明它是唯一的.
    欧拉旋转定理给了我们两个方法来描述 *定向*.假设我们选择了一个旋转角 $\theta$ 和一个 _经过原点_ 且与单位
向量 $\hat{n}$ _平行_ 的旋转轴.
    有了 $\hat{n}$ 和 $\theta$ 这两个值,我们就可以以 *轴-角*[axis-angle]形态来描述 *角位移*[angular displacement].或
者说由于 $\hat{n}$ 是单位向量,我们让它与 $\theta$ 相乘而不丢失信息,得到一个向量 $\vec{e} = \theta\hat{n}$.这个描绘旋转的技巧有一个
不明觉厉的名字- *exponential map*[指数映射].
    指数映射中,
    1.) 角 $\theta$ 可以通过 $e$ 的长度推断出来, $\theta = ||e||$;
    2.) 轴 $\hat{n}$ 则可以通过 *标准化*[normalizing] $\vec{e}$ 得到,$\hat{n} = \hat{e} = \frac{\vec{e}}{||e||}$.
    *指数映射* 不仅比 *轴角* 更紧凑(三个参数),在优雅的避开了某些奇点的同时还有更好的插值和微分能力.
    在此解释一下,在 *轴-角* 中描述角位移需要 $(\theta,\hat{n})$,其中$\hat{n}$ 作为一个向量其实可分解为 $(n_{x},n_{y},n_{z})$,所
以 _在 *轴-角* 中描述一个角位移需要4个数_. 而在 *指数映射* 中,有$\vec{e} = \theta\hat{n}$,由于单位向量不损失信息,所
以我们可以仅用 $\vec{e}$ 来描述 *角位移*,所以说 _在 *指数映射* 中描述一个角位移只需要3个数_.
    *指数映射*[exponential map]比 *轴角*[axis-angle]常用的多.首先, *指数映射* 插值比 *欧拉角* 更好.虽
然它有 *奇点*[singularities],却没有欧拉角的问题那么麻烦.通常当人们想到旋转的插值时,立刻想到的都是四
元数,然而在一些应用上,如存储动画数据, *指数映射* 是一个强有力的替代项.但是 *指数映射* 最常见的应用
不仅是在存储 *角位移* 上,更是在存储 *角速度*[angular velocity]上.原因在于 *指数映射* 的微分效果很好,
同时用来表示多重旋转也很简单.
    和 *欧拉角* 一样, *轴-角* 和 *指数映射* 也存在 *别名*[aliasing] 和 *奇点*[singularities],虽然限制没那
么严重. 
    *奇点* -> 在 $\theta = 0$ 时,任何轴都可能被使用.然而对 *指数映射* 而言,在 $\theta = 0$ 时,可知 $\vec{e} = \theta\hat{n}$,在这个
时候 $\vec{e}$ 将消失,所以不管 $\hat{n}$ 怎么取都没意义了.
    *别名* -> 在 *轴-角* 中,对 $\theta , \hat{n}$ 同时 _取负_ 将导致 *别名* 问题,而 *指数映射* 完美回避了这个问题,因
为在 $\vec{e} = \theta\hat{n}$ 中 $\theta,\hat{n}$ 同时取负值不变.
    其他 *别名* 问题就没怎么容易打发了.已知让 $\theta + 360^{\circ}k$ 得到的 *定向* 是相等的,这在 *轴-角* 和 *指数
映射* 中仍然存在.但这却不一定总是缺点,因为在描述 *角旋转*[angular velocity]时,能表示旋转了多少次是
非常有用的,所以我们才说, *指数映射* 的真正舞台在 *角旋转*.
    从上面的描述你已经可以感受到 *指数映射* 的牛逼了吧,好好学:).
*** 8.5 Quaternions[四元数]
    *四元数*[quaternion]在3D数学中是一个时髦的术语.它带有一定的神秘感--委婉的告诉了大家四元数复杂
又让人困惑.我们希望能用一些不同的方法来减轻四元数带来的神秘感.
    对于为什么只使用三个数的欧拉角在三维空间中表示一个 *定向* 会带来如 *万向锁* 这样的问题,有一个数
学上的解释.这涉及到一些相当高级的数学主题,如 *流形*[manifolds].四元数用四个数来表示一个 *定向* 以
避免 *万向锁* 的问题.
    本节将讲述如何使用四元数来定义一个 *角位移*[angular displacement].为了区别于传统意义上解释四元
数的方法(将四元数解释成数字),我们将主要从几何角度来看待四元数.
**** Quaternion Notation[四元数记法]
    一个四元数由两部分组成,1.) *标量*[scalar] 和 2.) *3D向量*.我们通常将标量部分用 $w$ 表示,向量部分用
$\vec{v}$ 或者 $(x,y,z)$ 表示.具体如下:
\begin{equation*}
\begin{bmatrix}
w & \vec{v}
\end{bmatrix},
\begin{bmatrix}
w & 
\begin{pmatrix}
x & y & z
\end{pmatrix}
\end{bmatrix}.
\end{equation*}
    同样我们也可以将四元数垂直表示:
 \begin{equation*}
\begin{bmatrix}
w \\
\begin{pmatrix}
x \\
y \\
z
\end{pmatrix}
\end{bmatrix}.
\end{equation*}
    不同于普通向量,四元数的 *行向量* 和 *列向量* 没有区别.
**** What Do Those Four Numbers Mean?[这四个数的含义是]
    四元数的格式和 *轴-角*, *指数映射* 非常接近.简要回顾下, *单位向量*[unit vector] $\hat{n}$ 定义了旋转的轴,
而标量 $\theta$ 则是围绕这个轴做旋转的 *量*.所以,$(\theta,\hat{n})$ 定义了 *轴-角* 系统下的 *角位移*[angular displace
ment].
    一个四元数也包含一个轴和角,但是 $\hat{n}$ 和 $\theta$ 不像 *轴-角* 一样,直接保存四元数的四个数字.相反,用了一个
初看很奇怪但实践证明高度实用的方法.下面的等式表现出了四元数的值与 $\theta$ 和 $\hat{n}$ 的关系.
\begin{equation*}
\begin{bmatrix}
w & \vec{v}
\end{bmatirx} =
\begin{bmatrix}
cos(\theta/2) & sin(\theta/2)\hat{n}
\end{bmatrix}
\end{equation*}
\begin{equation*}
\begin{bmatrix}
w &
\begin{pmatrix}
x & y & z
\end{pmatrix}
\end{bmatrix} =
\begin{bmatrix}
cos(\theta/2) & 
\begin{pmatrix}
sin(\theta/2)n_{x} & sin(\theta/2)n_{y} & sin(\theta/2)n_{z}\\
\end{pmatrix}
\end{bmatrix}.
\end{equation*}
    记住 $w$ 与 $\theta$ 相关,但它们不是同一个东西,$\vec{v}$ 和 $\hat{n}$ 也是如此.下面的小节将会分别从算数和几何的角度来讨
论四元数的运算.
**** Quaternion Negation[四元数的负数形式]
     四元数可以取负.比如:
     \begin{equation*}
     -\vec{q} = -
     \begin{bmatrix}
     w &
     \begin{pmatrix}
     x & y & z
     \end{pmatrix}
     \end{bmatrix} =
     \begin{bmatrix}
     -w &
     \begin{pmatrix}
     -x & -y & -z
     \end{pmatrix}
     \end{bmatrix}= -
      \begin{bmatrix}
     w & -\vec{v}
     \end{bmatrix}=
      \begin{bmatrix}
     -w & -\vec{v}
     \end{bmatrix}    

     \end{equation*}
     最神奇的地方在于将一个四元数取负不会有任何变化,至少在 *角位移* 方面.
     四元数 $\vec{q},-\vec{q}$ 描述同一个 *角位移*.任何角位移在3D里都能用两个四元数来表示,并且它们互为负数.
     发现这个原理其实并不难,如果我们让 $\theta$ 增加 $360^{\circ}$ ,它不会改变 $\vec{q}$ 的角位移,但是它会让 $\vec{q}$ 的四个元素都
取负.(因为 $w = cos(\theta/2) , \vec{v} = sin(\theta/2)\hat{n}$)
**** Identity Quaternions[单位四元数]
     从几何上来看,这里有两个 *单位四元数* 能表示 _没有角位移_.它们是:
     $[1 \ \vec{0}]$ 和 $[-1 \ \vec{0}]$.
     当 $\theta$ 是 $360^{\circ}$ 的 *偶数*[even]倍,有 $cos(\theta/2) = 1$;
     当 $\theta$ 是 $360^{\circ}$ 的 *奇数*[odd]倍,有 $cos(\theta/2) = -1$.
     在两种情况下,$sin(\theta/2) = 0$,所以说与 $\hat{n}$ 值无关.于是我们可以说,如果绕轴旋转的角度都是完整的周期,
那么在这种旋转下物体的 *定向* 不会有任何改变.
     在代数上来看,只有一个 *单位四元数*:$[1 \ \vec{0}]$.让任意向量 $\vec{q}$ 与单位四元数相乘,结果都是 $\vec{q}$.当我们让 $\vec{q}$ 与
$[-1 \ \vec{0}]$ 相乘,我们得到 $-\vec{q}$,几何上来看它们相等,但在数学上,两者不等,所以说在代数上,$[-1 \ \vec{0}]$ 不是"真正"的
*单位四元数*.
**** Quaternion Magnitude[四元数的模]
     求四元数的 *模*[magnitude] 很简单,方法如下:
     $||\vec{q}|| = || [w \ (x \ y \ z)] || = \sqrt{w^{2}+x^{2}+y^{2}+z^{2}} = || [w \ \vec{v}] || = \sqrt{w^{2} + ||v||^{2}}$.
     让我们看看 *旋转四元数*[rotation quaternion]的几何意义:
     \begin{equation*}
     \begin{align}
     ||q||  &= ||[w \ \vec{v}]|| = \sqrt{w^{2} + ||v||^{2}}
     \\&=
      \sqrt{cos^{2}(\theta/2) + (sin(\theta/2)||\hat{n}|| )^{2}}
     \\&=
      \sqrt{cos^{2}(\theta/2) + sin^{2}(\theta/2) ||\hat{n}||^{2}}
     \\&=
      \sqrt{cos^{2}(\theta/2) + sin^{2}(\theta/2)(1)}
     \\&=
 \sqrt{1}
     \\&= 1
     \end{align}
     \end{equation*}
     对使用四元数来表示 *定向* 而言,所有的四元数都被叫做 *单位四元数*[unit quaternions],并且它们的模
都为1.
**** Quaternion Conjugate and Inverse[四元数的共轭和逆]
     四元数的 *共轭*[conjugate],记作 $\vec{q}^{*}$ ,通过让四元数的向量部分取负得到:
     $\vec{q}^{*} = [w \ \vec{v}]^{*} = [w \ -\vec{v}] = [w \ (x \ y \ z)]^{*} = [w \ (-x \ -y \ -z)]$.
     术语 *共轭*[conjugate] 来自对四元数作为 *复数*[complex]的解释.
     四元数的 *逆*[inverse],记作 $q^{-1}$,由以下等式得到:
     $\vec{q}^{-1} = \frac{\vec{q}^{*}}{||\vec{q}||}$.
     我们知道在 *实数*[real number]中,$a \cdot a^{-1} = 1$,而四元数与其逆相乘,得到的结果是 *单位四元数*:$[1 \ \vec{0}]$.
     上面的等式是四元数的逆的标准定义.但是如果你只是对用四元数表示旋转感兴趣,就像我们在本书中的内容
一样,本书中涉及的四元数都是 *单位四元数*,这就意味着四元数的 *逆* 和它的 *共轭* 是相等的.
      *共轭* (*逆*)有意思的地方在于 $\vec{q}$ 和 $\vec{q}^{*}$ 的角位移正好相反,因为我们知道共轭的操作是对四元数 $\vec{q}$ 里的
向量 $\vec{v}$ 取负,也就导致了单位向量 $\hat{n}$ 也取负,这种情况下由于 $\hat{n}$ 和 $-\hat{n}$ 是平行的,所以结果只是导致 $\vec{q}$ 和 $\vec{-q}$
方向相反,也即是两者的角位移相反.
     其实为了 *共轭* 也可以只让 $w$ 为负,那样会得到一个更符合直觉的解释,但是考虑到术语 *共轭*[conjugate]
具有 *复数*[complex numbers]的含义,在此让 $\vec{v}$ 取负更符合原意.
**** Quaternion Multiplication[四元数乘法]
     四元数可以相乘.结果和向量的 *叉积*[cross product]相同,将会产生一个新的四元数(而不是标量),并且不
符合 *交换律*[commutative].区别在于所用的符号不同,我们在进行四元数的乘法时只需要把两个四元数并排
放在一起.现在让我们来看看具体的例子:
\begin{equation*}
\begin{align*}
\vec{q}_{1} \vec{q}_{2} &=
[w_{1} \ (x_{1} \ y_{1} \ z_{1})]
[w_{2} \ (x_{2} \ y_{2} \ z_{2})]
\\&=
\begin{bmatrix}
w_{1}w_{2} - x_{1}x_{2} - y_{1}y_{2} - z_{1}z_{2} \\
\begin{pmatrix}
w_{1}x_{2} + x_{1}w_{2} + y_{1}z_{2} - z_{1}y_{2} \\
w_{1}y_{2} + y_{1}w_{2} + y_{1}x_{2} - x_{1}z_{2} \\
w_{1}z_{2} + z_{1}w_{2} + x_{1}y_{2} - y_{1}x_{2} \\
\end{pmatrix}
\end{bmatrix}
\\&=
[w_{1} \ \vec{v}_{1}]
[w_{2} \ \vec{v}_{2}]
\\&=
[w_{1}w_{2} - \vec{v}_{1} \cdot \vec{v}_{2} \ w_{1}\vec{v}_{2}+w_{2}\vec{v}_{1} + \vec{v}_{1} \times \vec{v}_{1}]
\end{align*}
\end{equation*}
    四元数乘法也被叫做 *Hamilton product*[汉密尔顿乘法],在后面我们再详细阐述.
    现在我们先来看看四元数乘法的 _三个性质_:
    _第一_,四元数乘法满足 *结合律*[associative],但不满足 *交换律*[commutative].
    $(\vec{a}\vec{b})\vec{c} =\vec{a}(\vec{b}\vec{c})$
    $\vec{a}\vec{b} \ne \vec{b}\vec{a}$.
    _第二_,四元数积的模等于四元数模的积:
    $||\vec{q}_{1}\vec{q}_{2}|| =||\vec{q}_{1}|| \ ||\vec{q}_{2}||$
    _第三_,四元数积的逆等于四元数逆的积:
    $(\vec{a}\vec{b})^{-1} = \vec{b}^{-1}\vec{a}^{-1}$
    $(\vec{q}_{1}\vec{q}_{2} \cdots \vec{q}_{n-1}\vec{q}_{n})^{-1} = \vec{q}_{n}^{-1}\vec{q}_{n-1}^{-1} \cdots \vec{q}_{2}^{-1}\vec{q}_{1}^{-1}$
    现在我们已经知道了四元数乘法的三个性质,接下来说说为什么这三个性质很有用.让我们将一个标准3D点
$(x,y,z)$ 扩展到 *四元数空间*[quaternion space],得到:
    $\vec{p} = [0,(x,y,z)]$.在这里$\vec{p}$ 不是一个有效的四元数,因为它的大小可以是任意的.
    让 $\vec{q}$ 作为一个 *旋转四元数*[rotation quaternion] ,记作$[cos(\theta/2),\hat{n}sin(\theta/2)]$.
    最让人惊讶的事情出现了,我们可以通过以下四元数乘法让点 $\vec{p}$ 围绕 $\hat{n}$ 旋转:
    (由于书写格式的美观问题,以后相关情况用黑体 $\boldsymbol{p}$ 代替 $\vec{p}$)
    $\boldsymbol{p}^{'} = \boldsymbol{q}\boldsymbol{p}\boldsymbol{q}^{-1}$.
    这就是大多数文献里的四元数了.你可以想象一下一个人上来就给你看这个表达式时你内心的心情:).在后面
我们将不使用 $\boldsymbol{q}\boldsymbol{p}\boldsymbol{q}^{-1}$ ,而仅仅通过几何旋转的方式来实现从四元数到矩阵的转换.
    现在我们要用四元数 $\boldsymbol{a}$ 来旋转向量 $\boldsymbol{p}$,然后再用 $\boldsymbol{b}$ 来旋转得到的结果:
    $\boldsymbol{p^{'}} = \boldsymbol{b(apa^{-1})b^{-1}} = \boldsymbol{(ba)p(a^{-1}b^{-1}) = (ba)p(ba)^{-1}}$
    可以发现,先绕 $\boldsymbol{a}$ 旋转再绕 $\boldsymbol{b}$ 旋转 _等价于_ 一个复合的绕 $\boldsymbol{ba}$ 的旋转,这是关键.(四元数乘法可以用于表示
旋转的复合,类似于矩阵乘法).
    另外要注意的是,对四元数乘法的复合形式, _一定要以 *从里到外* 的顺序 *从右向左* 读_.
**** Quaternion "Difference"[四元数"差"]
     通过四元数乘法和它的逆,我们可以计算出两个四元数的差,这里的"差"被定义为一个 *定向* 到另一个 *定向*
的 *角位移*.也就是说,给定两个 *定向* $\vec{a},\vec{b}$,我们可以计算出从$\vec{a}$ 到 $\vec{b}$ 位移的量 $\vec{d}$.可以被表示为:
     $\boldsymbol{da = b}$.
     (记住四元数乘法的旋转顺序是从右到左的).
     现在来求 $\vec{d}$.如果等式中的变量为 *标量*[scalar],那么直接除 $\vec{a}$ 就行了,但是四元数不能做除法.我们只能
乘它.现在要考虑的就是如何消掉左边的$\vec{a}$,要想消掉四元数,就需要考虑得到它的单位四元数,于是我们就能想
到要对 $\vec{a}$ 取逆,注意四元数乘法不满足交换律,有:
     $\boldsymbol{(da)a^{-1} = ba^{-1}}$,
     $\boldsymbol{d(aa^{-1}) = ba^{-1}}$,
     $\boldsymbol{d[1 \ \vec{0}] = ba^{-1}}$,
     $\boldsymbol{d = ba^{-1}}$..
     现在我们有了一个能 _用四元数来求一个方位到另一个方位的 *位移* 的方法_.
     在数学上,两个四元数的 *差* 更类似于 *除*,而不是真正的 *差* (减).(想想 $\boldsymbol{da = b}$ )
**** Quaternion Dot Product[四元数的点积]
     四元数的点积是定义了的.符号和定义都和向量的点积相似:
     $\vec{q}_{1} \cdot \vec{q}_{2} = [w_{1} \ \vec{v}_{1}] \cdot [w_{2} \ \vec{v}_{2}]$
                 $= w_{1}w_{2} + \vec{v}_{1} \cdot \vec{v}_{1}$
                 $= [w_{1} (x_{1} \ y_{1} \ z_{1})] \cdot [w_{2} (x_{2} \ y_{2} \ z_{2})]$
                 $= w_{1}w_{2} + x_{1}x_{2} + y_{1}y_{2} + z_{1}z_{2}$.
     和向量点积一样,四元数点积的结果也是 *标量*[scalar].对 *单位四元数*[unit quaternions] $\hat{a},\hat{b}$ 来说,有
$-1 \le \boldsymbol{a \cdot b} \le 1$.
    虽然在游戏编程中,四元数点积的使用不太频繁,但是它却有一个有意思的几何解释.在前面关于四元数 *差*
的章节中,我们知道了四元数差 $\boldsymbol{d = ba^{*}}$.(假定是单位四元数,四元数的共轭和逆一样).如果我们扩展乘法并
且检查 $\vec{d}$ 的内容,会发现一个震惊的结果: $w = \boldsymbol{a \cdot b}$.
    在几何上这意味着什么?想一想 *欧拉旋转定理*[Euler's rotation theorem]:通过选择一个特定的轴,我们可
以只用旋转一次就让定向 $\vec{a}$ 旋转到定向 $\vec{b}$.这个唯一确定的轴和角度的信息就被塞到了 $\vec{d}$ 里.通过 $w$ 和 $\theta$ 的
关系我们还可以知道: $\boldsymbol{a \cdot b} = cos(\theta/2)$.其中的 $\theta$ 表示的是从定向 $\vec{a}$ 到定向 $\vec{b}$ 所走过的角度.
    虽然在游戏编程中点积不怎么常用,但它却是后面我们对 *slerp function* 进行分析的第一步.
**** Quaternion log, exp, and Multiplication by a Scalar[四元数的对数,指数和标量乘法运算]
     下面介绍四元数的三种运算, *对数*[logarithm], *指数*[exponential] 和 *标量乘法*.
     首先,让我们通过 $\alpha$ 来重定义一个四元数:
     $\alpha = \theta/2, \vec{q} = [cos\alpha \ \hat{n}sin\alpha]$.
     则 $\vec{q}$ 的对数为:
     $log \ \vec{q} = log([cos\alpha \ \hat{n}sin\alpha]) \equiv [0 \ \alpha\hat{n}]$.
     这里的 $\equiv$ 表示恒等于.总之 $log\vec{q}$ 不是一个 *单位四元数*.
     注意四元数取对数的运算与 *指数映射*[exponential map]的相似之处.

     而指数函数却是用相反的方式来定义的.首先,我们定义一个四元数 $\vec{p}$,其中 $(\vec{p},\vec{p} = [0,\alpha\hat{n}],||\hat{n}|| = 1)$.
     则指数函数被定义为:
     $exp \ \vec{p} = exp ([0 \ \alpha\hat{n}]) \equiv [cos\alpha \ \hat{n}sin\alpha]$.
     注意,根据定义,$exp \ \vec{p}$ 总是返回一个 *单位四元数*.
     对任意标量a,存在:
     $e^{lna} = a$.
     同样,四元数的指数函数其实是被定义为四元数对数函数的 *逆*.有:
     $exp(log \ \vec{q}) = \vec{q}$.
     
     最后,四元数与向量乘法,很简单,定义如下;
     $k\vec{q} = k[w \ \vec{v}] = [kw \ k\vec{v}]$.     
**** Quaternion Exponentiation[四元数的幂]
     四元数可以 *求幂*[exponentiated],记作 $\boldsymbol{q^{t}}$,不要将其与 *指数函数*[exponential function] $exp \ \vec{q}$ 混淆.
*指数函数*[exponential function]只接受一个参数:一个四元数.而四元数的 *幂*[exponentiation]有两个参数:
四元数$\vec{q}$ 和一个标量 $t$.
     四元数的幂和实数的幂表示的意义是相同的.对任何标量 $a$来说,除了 $a=0$,都满足 $a^{0}=1,a^{1}=a$.
对指数 $t,t \in [0,1]$ 而言,$a^{t}$ 的值范围为 $[1,a]$.当$t$ 从0到1时,四元数的幂 $\boldsymbol{q}^{t}$ 值从 $[1,\vec{0}]$ 变到 $\boldsymbol{q}$.
     四元数的幂的作用在于 _能让我们提取角位移的某个部分出来_.在大部分时候,幂不处于$[0,1]$ 时也能保持正
常,除了一个问题.
     举个例子,如果 $\boldsymbol{q}$ 表示绕x轴顺时针旋转30°,那么 $\boldsymbol{q}^{2}$ 就表示绕x轴顺时针旋转60°,$\boldsymbol{q}^{-1/3}$ 表示绕x轴顺时针
旋转10°.值得注意的是它的逆 $\boldsymbol{q}^{-1}$ 仍然有效:表示绕x轴逆时针旋转30°.
     真正的问题在于:四元数在表示 *角位移* 时使用的是最短的那条弧,这就意味着,当我们的目的时进行多次周
期旋转时,四元数无法表示出来.比如按之前 $\boldsymbol{q}$ 的定义,$\boldsymbol{q}^{8}$ 应该表示的是绕x轴顺时针旋转240度,然而在四元数
里结果却是绕逆时针绕x轴旋转120°.本质原因在于,四元数表示的只是旋转后的结果.总之要注意,在代数中成立的运算,
比如 $(a^{s})^{t} = a^{st}$ ,在四元数中并不能成立.
     而在某些情况下(最重要的一个例子是 *角速度* 的计算),我们确实需要将具体绕的圈数表示出来,这个时候
四元数就无法满足要求了.在这种情况下,还是应该考虑之前我们讲的 *指数映射*[exponential map].
     现在我们来看看四元数的幂是如何定义的:
     $\boldsymbol{q}^{t} = exp (t \, log \, \boldsymbol{q})$.
     想想标量的幂定义:
     $a^{t} = e^{t \, ln \, a}$.
     不难理解为什么当t从0变到1时 $\boldsymbol{q}^{t}$ 从 *单位四元数* $[1,\vec{0}]$ 变到 $\vec{q}$.注意, *对数运算*[log]本质上是将四元数
转换成 *指数映射*.然后再与指数t进行标量乘法,结果是$t\theta$,最后, *指数运算*[exp] 撤销了 *对数运算*[log]的
操作,从$t\theta$ 和 $\hat{n}$ 重新计算了 $w$ 和 $\vec{v}$.
**** Quaternion Interpolation,a.k.a. Slerp[四元数插值-Slerp]
     *slerp* 的完整含义是 *球面线性插值*[Spherical Linear interpolation],slerp的作用在于让我们能在两个
定向之间进行平滑的过渡(插值),并且它避免了欧拉角插值所遇到的所有问题.
     slerp 是一个 *三元运算符*[ternary operator],这意味着它接受三个 *操作数*[operands].前两个参数是我
们希望进行插值的四元数,假设开始和结束的两个 *定向* 分别为 $\boldsymbol{q}_{0},\boldsymbol{q}_{1}$,第三个参数则设为变量$t,t \in [0,1]$.
则slerp可表示为,$slerp(\boldsymbol{q}_{0},\boldsymbol{q}_{1},t)$,返回值是一个 *定向*,是两者之间的某个插值.
     来看看我们能否根据当前的工具得到slerp的公式.先从最简单的插值公式开始:
     $\triangle a = a_{1} - a_{0}$,
     $lerp(a_{0},a_{1},t) = a_{0}+t \triangle a$.
     标准的线性插值公式有三个步骤:
     1.) 计算两个值之差.
     2.) 取差的一部分.
     3.) 在初始值上加上步骤 2).
     我们可以在计算 *定向* 的插值上采用同样的方案.(但是要记住四元数乘法是从右向左读的).
     1.) 计算两个值的差.
        $\boldsymbol{\triangle q = q_{1}q_{0}^{-1}}$ (注意,是从$q_{0}$ 到 $q_{1}$).
     2.) 取差的一部分.
        $\boldsymbol{(\triangle q)^{t}}$.
     3.) 在初始值上加上步骤 2).
        $\boldsymbol{(\triangle q)^{t}q_{0}}$. (注意,从右到左读)
     这样我们就得出了slerp(理论上的表达式):
     $slerp(\boldsymbol{q_{0},q_{1},t}) = \boldsymbol{(q_{1}q_{0}^{-1})^{t} q_{0}}$.
     在实际的编程中,我们用了一个等价但是效率却更高的公式.为了推导出这个替代公式,我们先将这些四元数
放在了4D的 *欧几里得空间*[Euclidian space].由于我们感兴趣的四元数都是单位四元数,所以它们都"生活"
在一个4D的 *超球面*[hypersphere]的平面上.(还记得slerp的名字吗: *spherical* linear interpolation).
     我们可以将这个平面可视化(如下图).假设由两个2D的单位向量,$(\vec{v}_{0},\vec{v}_{1})$,我们希望计算两者的插值 $\vec{v}_{t}$,而
$\omega$ 则是从 $\vec{v}_{0}$ 到 $\vec{v}_{1}$ 的弧所截的角.则 $\vec{v}_{t}$ 就是从 $\vec{v}_{0}$ 开始沿弧旋转角度 $t\omega$ 所得的结果.
      [[file:image/Figure 8.11.png]]t 
     我们可以将 $\vec{v}_{t}$ 看成是 $\vec{v}_{0}$ 和 $\vec{v}_{1}$ 的 *线性组合*[linear combination].换句话说,存在$k_{0},k_{1}$ 使得:
      $\vec{v}_{t} = k_{0}\vec{v}_{0} + k_{1}\vec{v}_{1}$.
     下图演示了具体操作.
      [[file:image/Figure 8.12.png]]
     观察上图,注意我们要求的量是 $k_{0},k_{1}$.
      $sin\omega = \frac{sin t\omega}{k_{1}\vec{v}_{1}} = \frac{sin t\omega}{k_{1}}$
      $k_{1} = \frac{sin t\omega}{sin \omega}$
      $k_{0} = \frac{sin (1-t)\omega}{sin \omega}$
     这样,$\vec{v}_{t}$ 可以被表示为:
      $\vec{v}_{t} = k_{0}\vec{v}_{0} + k_{1}\vec{v}_{1} = \frac{sin (1-t)\omega}{sin \omega} \vec{v}_{0} + \frac{sin t\omega}{sin \omega}\vec{v}_{1}$.
     现在我们可以得到slerp:
      $slerp(\vec{q}_{0},\vec{q}_{1},t) = \frac{sin (1-t)\omega}{sin \omega} \vec{q}_{0} + \frac{sin t\omega}{sin \omega}\vec{q}_{1}$
     这里的 $\omega$ 是两个四元数之间的角度,我们可以将四元数的 *点积* 看成是返回 $cos\omega$ .
     这里还是有两个复杂的地方.
     首先,虽然 $\vec{q},\vec{-q}$ 表示相同的 *定向*,但是作为slerp的参数时却可能计算出不同的结果,在2D和3D中不会出
现这种状况,但是在4D的 *超球面*[hypersphere]中的 *拓扑学*[topology]却不同于传统的 *欧几里得空间*
[Euclidian space].方法就是让 $\vec{q_{0}},\vec{q_{1}}$ 都取正,这样点积的结果就不会为负.
     其次,就是当 $\omega$ 非常小的时候,会导致 $sin\omega$ 的值接近于0,这样在计算机进行除法的时候可能会造成错误.
所以在这种情况下,我们选择改用普通的 *线性插值*[linear interpolation].
**** Advantages and Disadvantages of Quaternions[四元数的优缺点]
     四元数的优点:
     - *平滑插值*.
       Smooth interpolation.
     - *快速连接和角位移求逆*.
       Fast concatenation and inversion of angular displacements.
     - *四元素/矩阵的互相转换非常迅速*.
       Fast onversion to and from matrix form.
     - *只包含四个数*.
       Only four numbers.
       
       四元数的缺点:
     - *略大于欧拉角*.
       Slightly bigger than Euler angles.
     - *存在无效值*.
       Can become invalid.
     - *对人来说不直观*.
       Diffult for humans to work with.
**** Quaternions as Complex Numbers[将四元数看作复数]
     关于四元数,我们在这儿才开始讨论通常在其他书里最开始就会讨论的内容: _将四元数看作复数_.
     如果你仅仅使用四元数来做旋转,完全可以跳过这个段落.如果你希望更进一步了解四元数,这个章节会很有
意思.这节将会阐释四元数的两个特性:
     1. 为什么是 $\theta/2$ 而不是 $\theta$.
     2. 关于 $\boldsymbol{qvq^{-1}}$.
     现在我们先来看一个有意思的东西,我们先将任意实数集嵌入一个 $2 \times 2$ 的矩阵,如下:
     \begin{equation*}
     a \equiv
     \begin{bmatrix}
     a & 0 \\
     0 & a
     \end{bmatrix}.
     \end{equation*}

     我们选择了一个 $2 \times 2$ 矩阵的子集并且建立了一个让这个矩阵与实数一一对应的映射.之所以建立这种映
射是因为它保留了所有的代数定律:加法,减法,乘法:交换律,分配律,0的性质等(除法等价于乘法的逆).比如:
\begin{equation*}
\begin{align}
\begin{bmatrix}
a & 0 \\
0 & a \\
\end{bmatrix}+
\begin{bmatrix}
b & 0 \\
0 & b \\
\end{bmatrix}=
\begin{bmatrix}
a+b & 0 \\
0 & a+b \\
\end{bmatrix},
\\
\begin{bmatrix}
a & 0 \\
0 & a \\
\end{bmatrix}-
\begin{bmatrix}
b & 0 \\
0 & b \\
\end{bmatrix}=
\begin{bmatrix}
a-b & 0 \\
0 & a-b \\
\end{bmatrix},
\\
\begin{bmatrix}
a & 0 \\
0 & a \\
\end{bmatrix}
\begin{bmatrix}
b & 0 \\
0 & b \\
\end{bmatrix}=
\begin{bmatrix}
ab & 0 \\
0 & ab \\
\end{bmatrix}.
\end{align}
\end{equation*}
     现在让我们看看能否建立一个关于复数的简单映射.如果你对复数有一点了解就会知道,复数对 $(a,b)$ 定义
了数 $a+bi$,其中 $i$ 满足 $i^{2} = -1$.这里的 $i$ 的意思是 *imaginary*,表示这是一个 _想象中才存在的数字_.
     关于复数的运算,我们只需要记住将所有 $i^{2}$ 都代换成 $-1$ 就行,比如:
     $(a+bi) + (c+di) = (a+c)+(b+d)i$,
     $(a+bi) - (c+di) = (a-c)+(b-d)i$,
     $(a+bi)(c+di) = ac+adi+bci-bd =(ac-bd) + (ad+bc)i$.
     现在,让我们来看看将复数加入进 $2 \times 2$ 矩阵后的效果:
     \begin{equation*}
     a+bi \equiv
     \begin{bmatrix}
     a & -b \\
     b & a
     \end{bmatrix}.
     \end{equation*}

     现在再来看看加入了复数后,矩阵运算是否仍然满足基本的定律:
      \begin{equation*}
     (a+bi) + (c+di)
     \equiv
     \begin{bmatrix}
     a & -b \\
     b & a
     \end{bmatrix}
     \begin{bmatrix}
     c & -d \\
     d & c
     \end{bmatrix}=
      \begin{bmatrix}
     a+c & -(b+d) \\
     b+d & a+c
     \end{bmatrix}
     \equiv
     (a+c)+(b+d)i
     \end{equation*}

     \begin{equation*}
     (a+bi) - (c+di)
     \equiv
     \begin{bmatrix}
     a & -b \\
     b & a
     \end{bmatrix}
     \begin{bmatrix}
     c & -d \\
     d & c
     \end{bmatrix}=
      \begin{bmatrix}
     a-c & -(b-d) \\
     b-d & a-c
     \end{bmatrix}
     \equiv
     (a-c)+(b-d)i
     \end{equation*}

      \begin{equation*}
     (a+bi)(c+di)
     \equiv
     \begin{bmatrix}
     a & -b \\
     b & a
     \end{bmatrix}
     \begin{bmatrix}
     c & -d \\
     d & c
     \end{bmatrix}=
      \begin{bmatrix}
     ac-bd & -(ad+bc) \\
     (ad+bc) & ac-bd
     \end{bmatrix}
     \equiv
     (ac-bd)+(ad+bc)i
     \end{equation*}
     
     再来看看 $i^{2}$ 用矩阵表示的情况:
     \begin{equation*}
      i^{2}
     \equiv
     \begin{bmatrix}
     i & 0 \\
     0 & i
     \end{bmatrix}^{2}
     =
     \begin{bmatrix}
     0 & -1 \\
     1 & 0
     \end{bmatrix}
     \begin{bmatrix}
     0 & -1 \\
     1 & 0
     \end{bmatrix}
     =
     \begin{bmatrix}
     -1 & 0 \\
     0 & -1
     \end{bmatrix}
     \equiv
     -1
     \end{equation*}
     在这里我们将 $[-1,0]$ 和$[1,0]$ 看成是坐标空间中的基向量,则我们会发现,与 $i$ 相乘的结果就是--作 $90^{\circ}$的
旋转.
     在这里我们还可以从线性代数的角度来考虑:将左边的矩阵看作要源坐标空间要变换的坐标,右边的矩阵为目
标坐标空间的基向量.当目标空间的基向量为单位向量时,即:
    \begin{equation*}
    i = 
    \begin{bmatrix}
    1 & 0 \\
    0 & 1\\
    \end{bmatrix}.
    \end{equation*}
    矩阵与其相乘,坐标显然不会变化(因为它是单位矩阵).
    这里再看看虚数 $i$,其矩阵形式为:
    \begin{equation*}
    i = 
    \begin{bmatrix}
    0 & -1 \\
    1 & 0\\
    \end{bmatrix}.
    \end{equation*}
    你会发现,它实际上就是单位向量旋转 $90^{\circ}$ 的结果.在这里,我们可以将左边的矩阵看作是输入的参数,右边的
矩阵看作是某个函数,最后的结果就是函数接收了参数后的输出.
    你可能会发现,线性代数的本质就是 _对基向量作线性变换_.
    在这里,不是将 $i$ 看作是 $-1$ 的平方根,而是将复数 $a+bi$ 分别看作是 *实数*[real number] $a$ 控制范围和
*虚数*[imaginary number] b控制范围的结合,而恰好两者的控制范围是互相垂直的.
    更进一步,我们可以以此来表示任意范围内的角度的旋转:
    \begin{equation*}
    cos\theta + i \, sin\theta
    \equiv
    \begin{bmatrix}
    cos\theta & -sin\theta \\
    sin\theta & cos\theta
    \end{bmatrix}.
    \end{equation*}
    观察复数的 *共轭*[conjugation]与矩阵转置相关的地方.注意四元数的 *共轭* 所表达的是 *角位移* 的 *逆*.
还有一点在于,由于两者互相垂直,所以旋转矩阵的 *逆* 等同于它的 *转置*.
    现在来考虑2D情况下向量的旋转.我们先将向量 $[x,y]$ 替换为 $x+iy$ ,再考虑复数的乘法实现旋转:
    $(cos\theta + isin\theta)(x+iy) = xcos\theta +iycos\theta + ixsin\theta - ysin\theta$
                                              $= (xcos\theta - ysin\theta) + i(xsin\theta+ycos\theta)$
    同样,再看看矩阵乘法实现旋转:
    \begin{equation*}
    \begin{bmatrix}
    cos\theta & -sin\theta \\
    sin\theta & cos\theta
    \end{bmatrix}
    \begin{bmatrix}
    x \\
    y \\
    \end{bmatrix}
    =
    \begin{bmatrix}
    xcos\theta - ysin\theta \\
    xsin\theta + ycos\theta \\
    \end{bmatrix}.
    \end{equation*}
    在我们进入3D之前,先对2D下的复数做一个总结:
    复数符合实数相关的运算规则,由两部分组成:实数和虚数,两者各控制一个范围.通常被表示为 $a+bi$,同样
可以被写作 $2 \times 2$ 的矩阵.当我们将复数看作矩阵时,乘以 $i$ 被看作是进行在几何上进行 $90^{\circ}$ 的旋转.而
 $i^{2} = -1$ 则被看成是进行了 $180^{\circ}$ 的旋转.
    更普遍的是,任意单位长度的复数都可以被写做 $cos\theta + isin\theta$ 且被解释为旋转 $\theta$ 度.

    现在来考虑3D情况下向量的旋转,首先我们想到的就是在原有基础上再加入一个参数来从2D拓展到3D.假设
3D下复数由三个部分组成,$a+bi+cj$,其中,$i^{2} = j^{2} = -1$.首先,我们不知道$ij$ 或者 $ji$ 的结果是什么,因
为未曾定义不同虚数的乘法.
    在这种情况下,我们必须要考虑将 $1,i,j$ 放入一个 $3 \times 3$ 的矩阵中.其中数字 $1$ 必然是3D单位矩阵 $\boldsymbol{I_{3}}$ 的映
射,而数字 $-1$ 则代表,$\boldsymbol{-I_{3}}$.现在我们要考虑的问题是怎么找到一个存在 $i,j$ 的矩阵M使 $M^{2} = \boldsymbol{-I_{3}}$.
    很明显我们知道$Det(\boldsymbol{-I_{3}}) = -1$,作为矩阵的根, $i,j$ 必须有一个值为 $-1$ 的行列式值(因为矩阵行列式
的乘积等同于矩阵乘积的行列式),唯一可能的情况就是$i,j$ 包含复数.可惜并不存在这个满足条件的复数.所以,
四元数应运而生.
    四元数通过引入三个 *虚数*[imaginary numbers]来解决这个问题.等式如下:
    $i^{2} = j^{2} = k^{2} = -1$

    $ij = k, \ ji = -k$
    $jk = i, \ kj = -i$
    $ki = j, \ ik = -j$
    这些四元数被记作 $[w,(x,y,z)]$,复数形式为 $w+xi+yj+zk$.
    现在继续回到矩阵上.我们能否创造一个含有复数并符合以上规则的 $4 \times 4$ 矩阵?实数和虚数分别如何表示?
    实数表示为:
    \begin{equation*}
    a \equiv
    \begin{bmatrix}
    a & 0 & 0 & 0 \\
    0 & a & 0 & 0 \\
    0 & 0 & a & 0 \\
    0 & 0 & 0 & a \\
    \end{bmatrix},
    \end{equation*}
    虚数表示为:
    \begin{equation*}
    i \equiv
    \begin{bmatrix}
    0 & 0 & 0 & 1 \\
    0 & 0 & -1 & 0 \\
    0 & 1 & 0 & 0 \\
    -1 & 0 & 0 & 0 \\
    \end{bmatrix},
    j \equiv
    \begin{bmatrix}
    0 & 0 & 1 & 0 \\
    0 & 0 & 0 & 1 \\
    -1 & 0 & 0 & 0 \\
    0 & -1 & 0 & 0 \\
    \end{bmatrix},
    k \equiv
    \begin{bmatrix}
    0 & -1 & 0 & 0 \\
    1 & 0 & 0 & 0 \\
    0 & 0 & 0 & 1 \\
    0 & 0 & -1 & 0 \\
    \end{bmatrix}.
    \end{equation*}
    先暂时说服自己接受这个等式:),等下再解释.
    组合上面的等式,我们可以将任何一个四元数以如下方式映射成 $4 \times 4$ 矩阵:
    \begin{equation*}
    w+xi+yj+zk \equiv
    \begin{bmatrix}
    w & -z & y & x \\
    z & w & -x & y \\
    -y & x & w & z \\
    x & -y & -z & w \\
    \end{bmatrix}.
    \end{equation*}
    观察这个矩阵,想想 *共轭* (令 $x,y,z$ 取负)和 *转置矩阵* 的相关性.
    从前面关于 $i,j,k$ 的矩阵我们知道其中交换并让某些轴取了负,其实它做的这些与之前的旋转矩阵有一定
的相似性.注意其中 $k$ 左上的 $2 \times 2$ 矩阵与2D时 $i$ 矩阵的相似性.换句话说,$k$ 的某部分具有绕z轴旋转$90^{\circ}$ 的
性质.
    类比于2D的情况,我们可以猜想 $cos\theta+ksin\theta$ 能表示为:绕z轴旋转$\theta$ .
    在2D时,我们将向量$[x,y]$ 映射为 $x+yi$.
    在3D中,让它与向量 $[1,0,0]$相乘.而考虑到 $[x,y,z]$ 被映射为复数 $0+xi+yj+zk$,那这里的向量
$[1,0,0]$ 也就成了 $i$,则有:
    $(cos\theta+ksin\theta)i = i cos\theta + ki sin\theta$
                                  $= i cos\theta + j sin\theta$
    实际上得到的结果是 $[cos\theta,sin\theta,0]$,正符合我们让x轴绕z轴旋转的目的.
    现在我们来进行更复杂一点的尝试,取向量 $[1,0,1]$,在复数上则表示为 $i+k$:
    $(cos\theta + ksin\theta)(i+k) = icos\theta + kcos\theta + kisin\theta + k^{2}sin\theta$
                                             $= icos\theta+jsin\theta+kcos\theta-sin\theta$
    得到的结果和向量无关,因为它含有一个非零的 $w$ 值.这个旋转在 *xy-plane* 工作的很好,但是 $z$ 部分并
不正确.在 *zw-hyperplane* 进行了额外的旋转.看看 $(cos\theta+ksin\theta)$ 实际上在 $4 \times 4$ 矩阵中的样子:
    \begin{equation*}
    cos\theta + ksin\theta \equiv
    \begin{bmatrix}
    cos\theta & -sin\theta & 0 & 0 \\
    sin\theta & cos\theta & 0 & 0 \\
    0 & 0 & cos\theta & sin\theta  \\
    0 & 0 & -sin\theta & cos\theta  \\
    \end{bmatrix}.
    \end{equation*}
    很明显,我们想要的只是左上角的旋转矩阵,而右下角的最好消失.现在考虑互换位置:
    互换前:
     $(cos\theta + ksin\theta)(i+k) = icos\theta + kcos\theta + kisin\theta + k^{2}sin\theta$
                                              $= icos\theta+jsin\theta+kcos\theta-sin\theta$
     互换后:
     $(i+k)(cos\theta + ksin\theta) = icos\theta + iksin\theta + kcos\theta + k^{2}sin\theta$
                                              $= icos\theta-jsin\theta+kcos\theta-sin\theta$                   (1)
     可以发现,唯一的区别就在于 *y-coordinate* 从正变成了负.好像还让事情更糟糕了...我们期望的关于绕
*xz-plane* 的旋转却进行了逆运算,现在我们得到了一个 $-\theta$,同时我们不期望进行的旋转仍然存在.
     再考虑作以下变换:
      $(i+k)(cos\theta - ksin\theta) = icos\theta + jsin\theta + kcos\theta + sin\theta$.                  (2)
      发现什么了没有?等式(1)给我们想要的结果,但是会附加一些额外的旋转,等式(2)的共轭让我们得到同样
的旋转,只是方向相反,如果我们将两者组合起来就会发现,额外的旋转被消掉了,只剩下我们期望的旋转,区别
在于进行了两次旋转,这个问题倒是容易解决,只要我们取 $\theta/2$ 就解决了.
     总结如下:
     首先,我们将向量$[x,y,z]$ 表示为四元数 $\vec{v} = [0,(x,y,z)]$,绕任意轴 $\hat{n}$ 旋转 $\theta$ 角的四元数被表示为:
$\vec{q} = [cos\theta,sin\theta\hat{n}]$.
     但是当进行乘法 $\boldsymbol{qv}$ 时,我们发现会导致 $w$ 的额外的旋转,而 $\boldsymbol{vq^{*}}$ 的额外部分分正好和 $\boldsymbol{qv}$的额外部分可
以互相抵消掉.但是进行了两次旋转.
     答案显然已经呼之欲出,只要我们令 $\vec{q} = [cos(\theta/2),sin(\theta/2)\hat{n}]$,再使用 $\boldsymbol{qvq^{*}}$ 来旋转,就解决了四元数
的旋转问题.
**** Summary of Quaternions[总结]
     虽然这一节介绍了很多数学知识,但是其中大多数都没有必要死记硬背.真正关键的东西都总结在这里了:

     - 本质上,一个四元数表示的是 _绕某个轴进行多少度旋转的角位移_.
     - 一个四元数包含 _一个标量w_ 和 _一个向量v_.$w$ 代表的是旋转角$\theta$,而$\vec{v}$ 代表的则是旋转轴.
       $w = cos(\theta/2), \ \ \vec{v} = \hat{n}sin(\theta/2)$.
     - 每个3d中的 *角位移* 在四元数中都有两种表示方式,区别只是两个四元数互为负数.
     - 单位四元数表示 _没有进行角位移_,记为 $[1,\vec{0}]$.
     - 所有表示角位移的四元数都是 *单位四元数*[unit quaternions],模为1.
     - 四元数的 *共轭*[conjugate]表示相反的 *角位移*,通过让四元数的向量部分取负得到.其逆则由公式:
       $\boldsymbol{q^{-1} = \frac{q^{*}}{||q||}}$,
       由于我们角位移时只考虑单位四元数,所以有: $\boldsymbol{q^{-1} = q^{*}}$.
     - 四元数乘法可以让多个旋转合并成一个单独的角位移.
     - 四元数的幂可以用来计算 *倍数角位移*[a multiple of an angular displacement].但是问题在于四元数
       的结果总是取最短的弧,就算进行了多次角位移也无法表现出来.
     - 四元数可以被解释成4d的复数.在数学和几何中我们都能感受到它的优美.
*** 8.6 Comparison of Methods[几项对比]
    现在我们来看看这几种不同 *定向* 的方式的对比:
    - *欧拉角* 最符合人的直觉.在实际场景中采用欧拉角能给人带来极大的方便.这点是最不应该被低估的.
    - 当涉及到向量的坐标空间转换时,最终一定会使用 *矩阵* 形式,虽然你也可以用其他形式来存储 *定向*.
    - 对涉及到大量 *定向* 数据的存储时(e.g 动画数据), *欧拉角*, *指数映射*, *四元数* 都可以纳入考虑.
      在这种情况下考虑的主要是节省内存.
    - 如果想要一个稳定靠谱的 *插值* 函数,使用 *四元数* 几乎是唯一的选择.就算是使用其他格式,也应该
      将其转换为四元数形式进行 *插值* 后再转换回去.使用 *指数映射* 来进行插值也是一个可选方案.
    - 对于需要 *角速度*[angular velocity]的状况(或者要保存多次旋转),使用 *指数映射* 或者 *轴-角*.
*** 8.7 Converting between Representations[各种形态的转换]
    本章讨论的是如何让 *角位移* 在各种形态之间转换.
**** 8.7.1 Converting Euler Angles to a Matrix[从欧拉角转换到矩阵]
    欧拉角定义了三个旋转序列.这三个旋转都是关于 *主轴*[cardinal axis] 的简单旋转.我们可以计算这个通
过连接多个旋转矩阵得到总角位移大小的矩阵.这项练习在很多书和网站里都有介绍.如果你用过这些参考资料,
可能会好奇:如果我用这个矩阵乘以一个向量会发生什么?
    之所以你会疑惑,是因为这里其实有两个不同的矩阵(当然其实两个矩阵互为转置),而通常这些资料里都不会
告诉你的是,这个矩阵是从 *object space* 旋转到 *upright space* 还是反之.
    考虑一个典型的情况,就是一个物体在实时移动.假设每个物体的 *定向* 都作为一个状态变量表示为欧拉角
的形式.其中一个物体是摄像机,而现在由于某种原因我们要将物体的坐标系传给 *图形接口*[graphics API].问
题就这样产生了:我们用来 _描述物体 *定向* 的矩阵_ 和用来 _描述摄像机 *定向* 的矩阵_ 不是同一个矩阵.
    *模型变换*[model transform]矩阵是将向量 _从 *object space* 转换到 *world space* 的矩阵_.
    *视角变换*[view transform]矩阵是将向量 _从 *world space* 转换到 camera's object space的矩阵_.
    一个是 *object-to-upright* 的矩阵,一个是 *upright-to-object* 的矩阵.
    让我们先来实现 *object-to-upright*,它的效果是将 *点*[points] 从 *object space* 旋转到 *upright space*.
我们使用 5.1.2节的旋转矩阵来实现(它参考的是3.3.1节的 *动态变换*[active transformation]的视角).想象一
个存在于物体上的任意一点,物体始于 *标准定向* ,在这个时候 *body coordinates* 和 *upright coordinates*
重合在一起.我们在这个物体上应用欧拉旋转,直到有外界的旋转之前,这个点都在这个空间内移动,这就说明了
这个物体位于能被 *欧拉角* 描述的 *定向* 里.至始至终,这些点都落在了 *upright coordinates* 内的任意 
*定向* 上.
     基础的旋转矩阵都是围绕 *主轴*[cardinal axis]旋转的.在欧拉角旋转中,旋转轴是 *body axes*,(在第一次
旋转后)可以是任意方向.所以说实际上我们不是绕 *body axes* 旋转,而是做 *fixed-axis* 旋转,其中的旋转是
围绕 *upright axes* 的.这意味着我们的旋转顺序是反的: _bank(roll) -> pitch -> heading(yaw)_.
     简而言之,一个 *object-to-upright* 旋转矩阵就是由三个旋转矩阵复合成的:

     $\boldsymbol{M}_{object \rightarrow upright} = \boldsymbol{BPH}$,
     
     其中的 $\boldsymbol{(B,P,H)}$ 就是旋转矩阵 $bank,pitch,heading$,三个矩阵分别绕z轴,x轴,y轴旋转.我们知道
怎么用矩阵来分别描述这三个旋转:
     \begin{equation*}
     \begin{align*}
     &\boldsymbol{B=R_{z}}(b)=
     \begin{bmatrix}
     cosb & sinb & 0 \\
     -sinb & cosb & 0 \\
     0 & 0 & 1
     \end{bmatrix},
     \\&
     \boldsymbol{P=R_{x}}(p)=
     \begin{bmatrix}
     1 & 0 & 0 \\
     0 & cosp & sinp \\
     0 & -sinb & cosp \\
     \end{bmatrix},
     \\&
     \boldsymbol{P=R_{y}}(h)=
     \begin{bmatrix}
     cosh & 0 & -sinh \\
     0 & 1 & 0\\
     sinh & 0 & cosh\\
     \end{bmatrix}.
     \end{align*}
     \end{equation*}
     将它们复合到一起,我们可以得到 *object-to-upright* 的欧拉角旋转矩阵:
     \begin{equation*}
     \boldsymbol{M}_{object \rightarrow upright} = \boldsymbol{BPH}=
     \begin{bmatrix}
     ch\,cb + sh \,sp\,sb & sb\,cp & -sh\,cb+ch\,sp\,sb \\
     -ch\,sb + sh\,sp\,sb & cb\,cp & sb\,sh + ch\,sp\,cb \\
     sh\,cp & -sp & ch\,cp\\
     \end{bmatrix}.
     \end{equation*}
     其中,
     $ch = cosh, \quad cp =cosp, \quad cb=cosb$
     $sh = sinh, \quad sp=sinp, \quad sb=sinb$
     对于那些从 *upright space* 到 *object space* 的向量,我们使用 *object-to-upright* 矩阵的 *逆*.(记住,
由于旋转矩阵是 *正交* 的,旋转矩阵的 *逆* 就等于它的 *转置*).
     
     而对于 *upright-to-object* ,我们要做的就是 *撤销*[undoing] *固定轴旋转*[the fixed-axis rotation].具
体顺序为: _undo(heading) -> undo(pitch) -> undo(bank)_.
     同之前一样,当物体(和它包含的点)进入空间内,我们就开始采用 *upright coordinates* 来描述它们了.唯一
的区别就在于我们一开始使用 *upright coordinates* ,在完成了最后的旋转后,物体的 *body axes* 和 *upright*-
*axis* 重合在一起了,而结果是一个 *object-space coordinates*.
     *upright-to-object* 的欧拉角旋转矩阵:
     \begin{equation*}
     \begin{align*}
     \boldsymbol{M}_{upright \rightarrow object} 
     &= \boldsymbol{H^{-1}P^{-1}B^{-1}}
     =\boldsymbol{R}_{y}(-h)\boldsymbol{R}_{x}(-p)\boldsymbol{R}_{z}(-b)
     \\&=
     \begin{bmatrix}
     ch\,cb + sh \,sp\,sb & -ch\,sb+sh\,sp\,cb & sh\,cp\\
     sb\,cp & cb\,cp & -sp\\
     -sh\,cb + ch\,sp\,sb & sb\,sh + ch\,sp\,cb & ch\,cp \\
     \end{bmatrix}.
     \end{align*}
     \end{equation*}
     *object-to-upright* 的欧拉角旋转矩阵:
     \begin{equation*}
     \boldsymbol{M}_{object \rightarrow upright} = \boldsymbol{BPH}=
     \begin{bmatrix}
     ch\,cb + sh \,sp\,sb & sb\,cp & -sh\,cb+ch\,sp\,sb \\
     -ch\,sb + sh\,sp\,sb & cb\,cp & sb\,sh + ch\,sp\,cb \\
     sh\,cp & -sp & ch\,cp\\
     \end{bmatrix}.
     \end{equation*}
     仔细看看就会发现两者互为转置矩阵.
**** 8.7.2 Converting Matrix to Euler Angles[从矩阵转换到欧拉角]
     将一个 *角位移* 从矩阵转换到欧拉角需要考虑一些情况:
     - 必须要先弄清楚具体的矩阵,是 *object-to-upright* 还是 *upright-to-object*.
     - 要考虑欧拉角存在 *别名*[aliasing].在转换的时候需要返回 *标准欧拉角*[canonical Euler angles].
     - 存在 *病态*[ill-formed]矩阵,我们必须要允许浮点数精度问题.
     考虑上述问题后,我们先来回顾下上一节得出的转换矩阵:
     \begin{equation*}
     \boldsymbol{M}_{object \rightarrow upright} = \boldsymbol{BPH}=
     \begin{bmatrix}
     ch\,cb + sh \,sp\,sb & sb\,cp & -sh\,cb+ch\,sp\,sb \\
     -ch\,sb + sh\,sp\,sb & cb\,cp & sb\,sh + ch\,sp\,cb \\
     sh\,cp & -sp & ch\,cp\\
     \end{bmatrix}.
     \end{equation*}
     观察矩阵,首先我们就可以得到 $p$,由矩阵元素 $m_{32}$:
     $m_{32} = -sinp, \quad -m_{32}=sinp, \quad arcsin(-m_{32}) = p$.
     由于现在我们已经知道 $p$ 的度数了,再次观察矩阵,通过$cosp$ 可以得到:
     $m_{31} = sinh \, cosp, \quad m_{33} = cosh \, cosp$,
     $m_{31}/cosp = sinh, \quad m_{33}/cosp = cosh$.
     $h = atan2(sinh,cosh) = atan2(m_{31},m_{33})$.
     同理可得 $b$,由矩阵元素 $m_{12},m_{22}$:
     $m_{12} = sinb \, cosp, \quad m_{12}/cosp = sinb$;
     $m_{22} = cosb \, cosp, \quad m_{22}/cosp = cosb;$
     $b=atan2(sinb,cosb) = atan2(m12,m22)$.
     这里要考虑的一种情况是 $cosp = 0$,由于除数不能为0,注意当 $cosp = 0$时,$p=\pm90^{\circ}$,这意味着我们只
能直直向上看或者向下看,这就是欧拉角的 *万向锁* 问题,其中 *heading*[偏航角] 和 *bank*[倾斜角]同时绕
垂直轴旋转.在这种情况下,我们将所有绕垂直轴的旋转都指定为 *heading*,而将 *bank* 设为0.如下:
     $cosp=0, \qquad b=0, \qquad sinb=0, \qquad cosb=1$,
     然后将其代入矩阵:
     \begin{equation*}
     \begin{bmatrix}
     ch\,cb + sh \,sp\,sb & sb\,cp & -sh\,cb+ch\,sp\,sb \\
     -ch\,sb + sh\,sp\,sb & cb\,cp & sb\,sh + ch\,sp\,cb \\
     sh\,cp & -sp & ch\,cp\\
     \end{bmatrix}=
     \begin{bmatrix}
     cosh & 0 & -sinh \\
     sinh\,sinp & 0 & cosh\,sinp \\
     0 & -sinp & 0 
     \end{bmatrix}.
     \end{equation*}
     观察矩阵,我们可以通过 $m_{13}$ 和 $m_{11}$ 来求得 $h$.
**** 8.7.3 Converting a Quaternion to a Matrix[从四元数转换到矩阵]
     1.) 四元数的格式为: $\vec{q} = (w,\vec{v})$ ,类似于 *轴角对*,也即是说四元数中进行旋转的 *轴* 和 *角度* 已经
确定了.
     2.) 在之前章节中我们学习了 _如何绕 *任意轴* 旋转 *任意角* 的方法_,矩阵如下:
     \begin{bmatrix}
     n_{x}^{2}(1-cos\theta)+cos\theta & n_{x}n_{y}(1-cos\theta)+n_{z}sin\theta & n_{x}n_{z}(1-cos\theta)-n_{y}sin\theta \\
     n_{x}n_{y}(1-cos\theta)-n_{z}sin\theta & n_{y}^{2}(1-cos\theta)+cos\theta & n_{y}n_{z}(1-cos\theta)+n_{x}sin\theta \\
     n_{x}n_{z}(1-cos\theta)+n_{y}sin\theta & n_{y}n_{z}(1-cos\theta)-n_{x}sin\theta & n_{z}^{2}(1-cos\theta)+cos\theta \\
     \end{bmatrix}
     3.) 四元数中的部分量:
     $w = cos(\theta/2), \, x = n_{x}sin(\theta/2), \, y = n_{y}sin(\theta/2), \, z = n_{z}sin(\theta/2)$.
     通过分解计算 $m_{11},m_{12}$ ...,我们可以得到一个 _由四元数构成的旋转矩阵_:
     \begin{bmatrix}
     1-2y^{2}-2z^{2} & 2xy+2wz & 2xz-2wy \\
     2xxy - 2wz & 1-2x^{2}-2z^{2} & 2yz+2wx \\
     2xz+2wy & 2yz-2wx & 1-2x^{2}-2y^{2}
     \end{bmatrix}
**** 8.7.4 Converting a Matrix to a Quaternion[从矩阵转换到四元数]
     由8.7.3节得到的四元数转换矩阵 $M$,我们可以反过来求四元数.
      \begin{bmatrix}
     1-2y^{2}-2z^{2} & 2xy+2wz & 2xz-2wy \\
     2xxy - 2wz & 1-2x^{2}-2z^{2} & 2yz+2wx \\
     2xz+2wy & 2yz-2wx & 1-2x^{2}-2y^{2}
     \end{bmatrix}
     检查其中的对角元素,可得:
     $tr(M) = m_{11} + m_{22} + m_{33}$
                  $= (1-2y^{2} - 2z^{2}) + (1-2x^{2} - 2z^{2}) + (1-2x^{2} - 2y^{2})$
                  $= 3-4(x^{2}+y^{2}+z^{2})$
                  $= 3-4(1-w^{2})$
                  $= 4w^{2} -1$,
     由此可得:
     $w = \frac{\sqrt{m_{11}+m_{22}+m_{33}+1}}{2}$.
     通过改变$m_{11},m_{22},m_{33}$ 的正负号来消元,我们可以分别得到另外三个数 $x,y,z$.
     $x = \frac{\sqrt{m_{11}-m_{22}-m_{33}+1}}{2}$.
     $y = \frac{\sqrt{-m_{11}+m_{22}-m_{33}+1}}{2}$.
     $z = \frac{\sqrt{-m_{11}-m_{22}+m_{33}+1}}{2}$.
     1.)由于$x,y,z$ 总不为负, 2.)由于 $\vec{q},\vec{-q}$ 代表相同 *定向*.所以我们选取非负根作为4个分量中的一个,仍
能得到正确的四元数.
**** 8.7.5 Converting Euler Angles to a Quaternion[从欧拉角转换到四元数]
     四元数形式为 $\vec{q} = (w,(x,y,z))$,欧拉角为 $(h,p,b)$.
     联想欧拉角与矩阵的转换,我们可以先分别将欧拉角的三个旋转表示出来:
     \begin{equation*}
     h =
     \begin{bmatrix}
     cos(h/2) \\
     \begin{pmatrix}
     0 \\
     sin(h/2) \\
     0
     \end{pmatrix}
     \end{bmatrix},
     p =
     \begin{bmatrix}
     cos(p/2) \\
     \begin{pmatrix}
     sin(p/2) \\
     0 \\
     0
     \end{pmatrix}
     \end{bmatrix},
     b =
     \begin{bmatrix}
     cos(b/2) \\
     \begin{pmatrix}
     0 \\
     0 \\
     sin(b/2) \\
     \end{pmatrix}
     \end{bmatrix}.
     \end{equation*}
     考虑到 1.)虽然同时存在 *object-to-upright* 和 *upright-to-object* 两个四元数, 2.)但是两者 *共轭*.
     所以只需要推导 *object-to-upright* 的四元数就行.
     $\boldsymbol{q}_{object \rightarrow upright}(h,p,b) = \boldsymbol{hpb} =$
     \begin{equation*}
     \begin{align*}
     &=
     \begin{bmatrix}
     cos(h/2) \\
     \begin{pmatrix}
     0 \\
     sin(h/2) \\
     0
     \end{pmatrix}
     \end{bmatrix}
     \begin{bmatrix}
     cos(p/2) \\
     \begin{pmatrix}
     sin(p/2) \\
     0 \\
     0
     \end{pmatrix}
     \end{bmatrix}
     \begin{bmatrix}
     cos(b/2) \\
     \begin{pmatrix}
     0 \\
     0 \\
     sin(b/2) \\
     \end{pmatrix}
     \end{bmatrix}
     \\&=
     \begin{bmatrix}
     cos(h/2)cos(p/2) \\
     \begin{pmatrix}
     cos(h/2)sin(p/2) \\
     sin(h/2)cos(p/2) \\
     -sin(h/2)sin(p/2) \\
     \end{pmatrix}
     \end{bmatrix}
     \begin{bmatrix}
     cos(b/2) \\
     \begin{pmatrix}
     0 \\
     0 \\
     sin(b/2) \\
     \end{pmatrix}
     \end{bmatrix}
     \\&=
     \begin{bmatrix}
     cos(h/2)cos(p/2)cos(b/2) + sin(h/2)sin(p/2)sin(b/2) \\
     \begin{pmatrix}
     cos(h/2)sin(p/2)cos(b/2) + sin(h/2)cos(p/2)sin(b/2) \\
     sin(h/2)cos(p/2)cos(b/2) - cos(h/2)sin(p/2)sin(b/2) \\
     cos(h/2)cos(p/2)sin(b/2) - sin(h/2)sin(p/2)cos(b/2) \\
     \end{pmatrix}
     \end{bmatrix}
     \end{align*}
     \end{equation*}
     而 *upright-to-object* 的四元数由共轭可得:
     $\boldsymbol{q}_{upright \rightarrow object}(h,p,b) = \boldsymbol{q}_{object \rightarrow upright}(h,p,b)^{*}$
     \begin{equation*}
     \begin{align*}
     \begin{bmatrix}
     cos(h/2)cos(p/2)cos(b/2) + sin(h/2)sin(p/2)sin(b/2) \\
     \begin{pmatrix}
     cos(h/2)sin(p/2)cos(b/2) + sin(h/2)cos(p/2)sin(b/2) \\
     sin(h/2)cos(p/2)cos(b/2) - cos(h/2)sin(p/2)sin(b/2) \\
     cos(h/2)cos(p/2)sin(b/2) - sin(h/2)sin(p/2)cos(b/2) \\
     \end{pmatrix}
     \end{bmatrix}
     \end{align*}
     \end{equation*}
**** 8.7.6 Converting a Quaternion to Euler Angles[从四元数转换到欧拉角]
     参考8.7.2节中的 $p,h,b$ 的表示:
     \begin{equation*}
     \begin{align*}
     &p = arcsin(-m_{32}), \\
     &h =
     \begin{cases}
     atan2(m_{31},m_{33})  & \mbox{if} cosp \neq 0,\\
     atan2(_m_{13},m_{11}) & \mbox{otherwise.}
     \end{cases} \\
     &b =
     \begin{cases}
     atan2(m_{12},m_{22})  & \mbox{if} cosp \neq 0,\\
     0 & \mbox{otherwise.}
     \end{cases}
     \end{align*} 
     \end{equation*}
     从之前的四元数转矩阵可得:
     $m_{11} = 1-2y^{2}-2z^{2}, \quad m_{12} = 2xy+2wz, \quad m_{13} = 2xz -2wy$,
     $m_{22} = 1-2x^{2}-2z^{2}$,
     $m_{31} = 2xz+2wy, \quad m_{32} = 2yz-2wx, \quad m_{33} = 1-2x^{2} -2y^{2}$.
     代入上面并化简,可得:
     \begin{equation*}
     \begin{align*}
     &p = arcsin(-m_{32}) = arcsin(-2(yz-wx)) \\
     &h =
     \begin{cases}
     atan2(m_{31},m_{33}) \\
     = atan2(2xxz+2wy,1-2x^{2}-2y^{2} & \mbox{if} cosp \neq 0,\\
     = atan2(xz+wy,1/2-x^{2}-y^{2}) 
     \\ \\
     atan2(_m_{13},m_{11}) \\
     = atan2(-2xz+2wy,1-2y^{2}-2z^{2}) & \mbox{otherwise.} \\
     = atan2(-xz+wy,1/2 -y^{2}-z^{2})
     \end{cases} \\
     &b =
     \begin{cases}
     atan2(m_{12},m_{22})  \\
     =atan2(2xy+2wz,1-2x^{2}-2z^{2}) & \mbox{if} cosp \neq 0,\\
     =atan2(-xz+wy,1/2-y^{2}-z^{2}) \\
     0 & \mbox{otherwise.}
     \end{cases}
     \end{align*} 
     \end{equation*}
** Chapter 9 Geometric Primitives[几何图元]
*** 9.1 Representation Techiniques[表现技巧]
    A. *implicit form*[隐式]

    1. *Unit sphere*[单位球]
    $x^{2}+y^{2}+z^{2} = 1$
    2. A *conic section*[圆锥曲线] is a 2D shape formed by the _intersection of a cone with a plane_.
    圆锥与平面相切的结果有四种:
    *circle*[圆] / *ellipse*[椭圆] / *parabola*[抛物线] / *hyperbola*[双曲线].
    都可由 $Ax^{2} + Bxy + Cy^{2} + D = 0$ 表示.
    [[file:image/Figure 9.1.png]]
    3. *metaballs*[元球] is an implicit method for representing *fluid*[流体] and *organic shapes*[有机体].
    元球由一系列 "球" 定义.每个球都定义了三个参数,每个参数以 _从球中心到某个点的距离_ 为 *标量*[scalar]
以表示 *密度*[density].距离球心越近,密度越大,反之,距离球心越远,密度越小.

    B. *parametric form*[参数式]

    4. *unit circle*[单位圆] in *parametric form*[参数式].
    $x(t) = cos2\pi t, y(t) = sin2\pi t, t \in [0,1]$
    [[file:image/Figure 9.2.png]]
    *参数式*[parametric form]举例:
    - *univariate*[单参数] --> 1D --> 曲线[curve].
    - *bivariate function*[双参数] --> 2D --> 面[plane].

    C. *straightforward form*[直觉式] --> 最符合人直觉的形式
    e.g 
    一条线由两个点(起点,终点)构成.
    一个圆,由圆心和半径构成.

    _Parametric circle_ with arbitrary center and radius.
    $x(t) = x_{c}+rcos2 \pi t \quad y(t) = y_{c} + rsin2 \pi t$.

    _Implicit circle_ with arbitrary center and radius.
    $(x - x_{c})^2 + (y - y_{c})^2 = r^{2}$
*** 9.2 Lines and Rays[直线和射线]
    *line segment*[线段]  <--> *line*[直线] <--> *ray*[射线]
    A. 在 *classical geometry* 中,
    - *line* <-------> 向两个方向无限延伸,有0个点.
    - *line segment* {---} 有起点和终点的 *line*,有2个点.
    - *ray* -----> 只有起点和方向,有1个点.
    B. 在 *computational geometry* 中,
    - *ray* 是一个 1.)有方向[direction] 的 2.)线段[line segment].
    
    本章重点 --> *ray* (计算机图形学中的定义),具体示例:
    *raycasting*[光线追踪],鼠标物体检测,击中检测.
**** Rays[射线]
     _Parametric definition of a ray using vector notation_.
     $\boldsymbol{p}(t) = \boldsymbol{p}_{0}+t\boldsymbol{d} \quad t \in [0,1]$.
     [[file:image/Figure 9.3.png]]
     其中,$\boldsymbol{p}(t)$ 表示终点,$\boldsymbol{p}_{0}$ 表示起点,$\boldsymbol{d}$ 表示方向和长度.
     
     _Parametric definition of a 2D ray_
     $x(t) = x_{0}+ t \triangle x, \quad y_{t} = y_{0} + t \triangle y$.
**** Special 2D Representations of Lines[线在二维中的特殊表示]
     *Slope-intercept form*[斜截式]:
     $y = mx + y_{0} \quad (m = rise/run, run\neq 0)$.
     
     [[file:image/Figure 9.5.png]]

     _implicit definition of infinite line in 2D_
     $ax+by = d$.

     _implicit definition of infinite 2D line using vector notation_
     $\boldsymbol{p \cdot n } = d, \quad \boldsymbol{n} = [a,b],\boldsymbol{p}=[x,y]$.
     [[file:image/Figure 9.6.png]]使用垂直的向量和到原点的距离来定义直线.
     其中,
     - $d$ 为从原点到$\boldsymbol{p}$ 的 *符号距离*[signed distance].($d$ 可能为正,也可能为负,取决于它与 $\boldsymbol{n}$ 的位置关系).
     - $\boldsymbol{n}$ 为垂直于 $\boldsymbol{p}$ 的单位向量.
     
     $\boldsymbol{p \cdot n = q \cdot n}$
     [[file:image/Figure 9.7.png]]使用垂直的向量和线上的点来定义直线.
     
     $distance(\boldsymbol{p,q}) = distance(\boldsymbol{p,r})$
     [[file:image/Figure 9.8.png]]将直线看作是某个线段的垂直等分线.
**** Converting between Representations[表达方式的转换]
     _points to parametric form_:
     $\boldsymbol{p}_{0} = \boldsymbol{p}_{org}, \quad \boldsymbol{d} = \boldsymbol{p}_{end} - \boldsymbol{p}_{org}$.
     _parametric form to two-points form_:
     $\boldsymbol{p}_{org} = \boldsymbol{p}_{0}, \quad \boldsymbol{p}_{end} = \boldsymbol{p}_{0} + \boldsymbol{d}$.

     _implicit line_:
     $a = d_{y}, \quad b = -d_{x}, \quad d = x_{org}d_{y} - y_{org}d_{x}$.
     _implicitly to slope-intercept form_:
     $m = -a/b, \quad y_{0} = d/b$.

     _implicitly to "normal and distance" form_:
     $\hat{n} = [a,b] / \sqrt{a^{2}+b^{2}}, \quad distance = d/ \sqrt{a^{2}+b^{2}}$.
     _normal and a point on the line to normal and distance form_:
     $distance = \hat{n} \cdot \vec{q}$

     _perpendicular bisector form to implicit form_
     $a = q_{y}-r_{y}, \quad b = r_{x}-q_{x}$,
    $d = \frac{\boldsymbol{q+r}}{2} \cdot [a , b] = r_{x}q_{y} - q_{x}r_{y}$.
*** 9.3 Spheres and Circles[球和圆]
     _Implicit definition of a sphere using vector notation_:
     $|| \boldsymbol{p-c}|| = r$.
     其中,$\boldsymbol{p}$ 为球表面上任意点, $\boldsymbol{c}$ 为圆心.$r$ 为半径.
     _Implicit definitions of a circle and a sphere_:
     $(x-c_{x})^{2} + (y-c_{y})^{2} = r^{2} \quad (2D circle)$,
     $(x-c_{x})^{2} + (y-c_{y})^{2} + (z - c_{z})^{2} = r^{2} \quad (3D sphere)$.
     与$r$ 相关概念:
     $D = 2r \quad$  --> *diameter*[直径]
     $C = 2 \pi r = \pi D$  --> *circumference*[周长]
     $A = \pi r^{2}$ --> *area of circle*[圆面积]
     $S = 4 \pi r^{2}$  --> *surface of sphere*[球表面积]
     $V = \frac{4}{3} \pi r^{2}$ --> *volume of sphere*[球体积]
*** 9.4 Bounding Boxes[边界盒]
     *AABB*[Axially aligned bounding box]
     与主轴(x,y,z)对齐的边界盒,即它的六个面分别平行于对应的主轴.
     *OBB*[oriented bounding box]
     [[file:image/Figure 9.9.png]]
     需要注意的地方在于,一个 *Bounding Box* 是一个 *AABB* 还是 *OBB*,取决于你从哪个坐标系观察它.
**** Representing AABBs[如何表示AABB]
     先介绍一些关于 *AABB* 的基本性质.
     1. AABB中的点满足:
        $x_{min} \le x \le x_{max}, \quad y_{min} \le y \le y_{max}, \quad z_{min} \le z \le z_{max}$.
     2. 两个角上的点表示为:
        $\boldsymbol{P}_{min} = [x_{min},y_{min},z_{min}], \quad \boldsymbol{P}_{max} = [x_{max},y_{max},z_{max}]$.
     3. 中心点 $\boldsymbol{c}$:
        $\boldsymbol{c} = (\boldsymbol{p}_{min} +\boldsymbol{p}_{max})/2$.
     4. *size vector*:
        $\boldsymbol{p_{max} - p_{min}}$.
     5. *radius vector*:
        $\boldsymbol{r = p_{max} - c = s/2}$.
     由上,我们有了 $\boldsymbol{p_{min},p_{max},c,s,r}$.
**** Computing AABBs[计算AABB]
     [[file:image/Listing 9.1.png]]
     [[file:image/Listing 9.2.png]]
     [[file:image/Listing 9.3.png]]
**** AABBs vs Bounding Spheres[AABB vs 边界球]
     AABB相较于BS的优点:
     1. 计算更简单,效率更高.
     2. 更严格的边界体积检测.
     注意,AABB由三个参数决定-> *长度,宽度,高度*.而BS只有一个参数-> *半径*.
     这意味着:AABB使用起来有更高的自由度,能适用于更多的物体.
     [[file:image/Figure 9.10.png]]
     当涉及到旋转的物体时,BS的优势就体现出来了(观察上图).
**** Transforming AABBs[AABB的转换]
     1. 首先我们要清楚,通常情况下, *object space* 中物体的 *AABB* 和 *world space* 中同样的物体的
*AABB* 是不同的.
     2. 考虑到一个物体通常由很多个三角形网格和顶点构成,如果物体旋转/缩放/拉伸过后再重新计算出物体
新的 *AABB*,这在效率上难以接受.
     3. 所以只有考虑将原有 *AABB* 转换成新的 *AABB*,但是会遇到如下情况:
     [[file:image/Figure 9.11.png]]
     旋转object得到的AABB不会改变大小,旋转object的AABB得到的新AABB会变大.(*world coordinate* 下).
*** 9.5 Planes[平面]
    *Plane*[平面], A plane is a flat, 2D subspace of 3D.
**** The Plane Equation: An Implicit Definition of a Plane[平面的隐式定义]
     对所有点 $\boldsymbol{p}=(x,y,z)$,满足:
     $ax+by+cz = d$               (scalar notation),
     $\boldsymbol{p \cdot n} = d$                             (vector notation).
     其中, $\boldsymbol{n} = [a,b,c]$,被叫做 *normal*[法线],因为它 *垂直*[perpendicular](normal) 于平面.
     *normal*[法线]决定了平面的 *定向*[orientation], $d$ 定义了它的 *位置*[position].
     假设存在点 $\boldsymbol{p,q}$ 在平面上,则有:
     $\boldsymbol{p \cdot n} = d$
     $\boldsymbol{q \cdot n} = d$
     $\boldsymbol{p \cdot n - q \cdot n} = 0$
     $\boldsymbol{n \cdot (p-q)} = 0$
**** Defining a Plane by Using Three Points[用三个点来定义一个平面]
     *Collinear points*[共线点] :点都在一条直线上.
     *noncollinear points*[非共线点]: 点都不在一条直线上.
     通过 _在同一平面上的三个 *非共线点* 可以组成一个平面_.
     [[file:image/Figure 9.12.png]]
     _The normal of a plane containing three points_
     $\boldsymbol{e_{3} = p_{2} - p_{1}}, \quad \boldsymbol{e_{1} = p_{3} - p_{2}}, \quad \hat{n} = \frac{e_{3} \times e_{1}}{||e_{3} \times e_{1}||}$.
**** "Best fit" Plane for More than Three Points[超过三个点如何构成最佳平面]
     *polygon*[多边形]:多个顶点构成的平面.
     _computing the best-fit plane normal from n points_:
     $n_{x} = \sum _{i=1}^{n} (z_{i}+z_{i+1})(y_{i}-y_{i+1})$,
     $n_{y} = \sum _{i=1}^{n} (x_{i}+x_{i+1})(z_{i}-z_{i+1})$,
     $n_{z} = \sum _{i=1}^{n} (y_{i}+y_{i+1})(_{i}-x_{i+1})$.
     
     _computing the best-fit plane d value_:
     $d$ 可以看作是每个点的 $d$ 所取平均值.
     $d = \frac{1}{n} \sum _{i=1} ^{n}(\boldsymbol{p_{i} \cdot n}) = \frac {1} {n} (\sum _{i=1} ^{n} \boldsymbol{p_{i}}) \cdot \boldsymbol{n}$.
**** Distance from Point to Plane[点到面的距离]
     [[file:image/Figure 9.13.png]]
     _computing the signed distance from a plane to an arbitrary 3D point_:
     $\boldsymbol{p} + a\boldsymbol{\hat{n}} = \boldsymbol{q}$,
     $(\boldsymbol{p} + a\boldsymbol{\hat{n}}) \cdot \boldsymbol{\hat{n}} = \boldsymbol{q \cdot \hat{n}}$,
     $d + a = \boldsymbol{q \cdot \hat{n}}$,
     $a = \boldsymbol{q \cdot \hat{n}} - d$.
*** 9.6 Triangles[三角形]
    三角形在建模和图形学中有举足轻重的作用.
    *triangle mesh*[三角网格] -> a group of connected triangles forms.
**** Notation[符号]
     三角形由 1.)一定顺序的 2.)三个顶点连接构成.在左手坐标系中,以顺时针定义.
     _Notation for edge vectors and lengths_:
     [[file:image/Figure 9.14.png]]

     $\boldsymbol{e_{1} = v_{3} - v_{2}}, \quad \boldsymbol{e_{2} = v_{1} - v_{3}}, \quad \boldsymbol{e_{3} = v_{2} - v_{1}}$,
     $l_{1} = ||\boldsymbol{e_{1}}||, \quad l_{2} = ||\boldsymbol{e_{2}}||, \quad l_{3} = ||\boldsymbol{e_{3}}||$.
     
     _law of sins_
     $\frac{sin\theta_{1}}{l_{1}} = \frac{sin\theta_{2}}{l_{2}} = \frac{sin\theta_{3}}{l_{3}}$,
     _law of cosins_
     ${l_{1}}^{2} = {l_{2}}^{2} + {l_{3}}^{2} - 2l_{2}l_{3} cos\theta_{1}$,
     ${l_{2}}^{2} = {l_{1}}^{2} + {l_{3}}^{2} - 2l_{1}l_{3} cos\theta_{2}$,
     ${l_{3}}^{2} = {l_{1}}^{2} + {l_{2}}^{2} - 2l_{1}l_{2} cos\theta_{3}$.
     _perimeter[周长] of a triangle_
     $p = l_{1} + l_{2} + l_{3}$.
**** Area o a Triangle[三角形面积]
     _Area of a triangle_
     $A = bh/2$.
     _Heron's formula for the area of a triangle_
     $s = \frac{l_{1}+l_{2}+l_{3}}{2} = \frac{p}{2}$,
     $A = \sqrt{s(s-l_{1})(s-l_{2})(s-l_{3})}$.
     [[file:image/Figure 9.15.png]]The area "beneath" an edge vector
     需要注意的是,当 *edge vector*  _从左到右时,面积为正,从右到左时,面积为负_.
     _The formulas for the areas under each edge_
     梯形面积公式: (上底+下底)*高/2.
     $\boldsymbol{A(e_{1})} = \frac {(y_{3}+y_{2})(x_{3}-x_{2})} {2}$,
     $\boldsymbol{A(e_{2})} = \frac {(y_{1}+y_{3})(x_{1}-x_{3})} {2}$,
     $\boldsymbol{A(e_{3})} = \frac {(y_{2}+y_{1})(x_{2}-x_{1})} {2}$.
     这里有意思的地方在于,当我们将三个edge vector围成的形状的 _有符号面积_ 相加,得到的就是三角形面积.
     更牛逼的在于,这个求面积方法不止对三角形有用,还能推广到所有 *多边形*[polygon].
     由此可得:
     $\boldsymbol{A = A(e_{1}) + A(e_{2}) + A(e_{3})}$
          $= \frac{(y_{3}+y_{2})(x_{3}-x_{2}) + (y_{1}+y_{3})(x_{1}-x_{3}) + (y_{2}+y_{1})(x_{2}-x_{1})}{2}$
          $= \frac{y_{1}(x_{2}-x_{3}) + y_{2}(x_{3}-x_{1}) + y_{3}(x_{1}-x_{2})}{2}$
     _computing the area of a 2D triangle from the coordinates of the vertices_
     考虑到两个事实, 1.)平移和旋转三角形,三角形面积不变. 2.)当某个edge vector垂直于x轴时,值为0.
     由此,我们可以这样来化简上面的式子:
     $\boldsymbol{A} = \frac{y_{1}(x_{2}-x_{3}) + y_{2}(x_{3}-x_{1}) + y_{3}(x_{1}-x_{2})}{2}$
          $= \frac{(y_{1}-y_{3})(x_{2}-x_{3}) + (y_{2}-y_{3})(x_{3}-x_{1}) + (y_{3}-y_{3})(x_{1}-x_{2})}{2}$
          $= \frac{(y_{1}-y_{3})(x_{2}-x_{3}) + (y_{2}-y_{3})(x_{3}-x_{1})}{2}$.
      
     _in 3D,area of a triangle_
     $\boldsymbol{A = \frac{|| e_{1} \times e_{2} ||}{2}}$.
     原因在于,向量叉乘的 *大小*[magnitude]等于两个向量构成的平行四边形的面积.而由于三角形面积为等长
宽的平行四边形的一边,由此得出上式.
**** Barycentric Space[重心坐标]
     定义:由 *单形* (三角形/四面体)的顶点定义的坐标.是 *齐次坐标* 的一种.
     之所以要在三角形里讲 *重心坐标*,是因为在进行变换的时候需要一个参考系.
     _Computing a 3D point from barycentric coordinates_
     $(b_{1},b_{2},b_{3}) \equiv b_{1} \boldsymbol{v_{1}} + b_{2} \boldsymbol{v_{2}} + b_{3} \boldsymbol{v_{3}}$.
     $b_{1}+b_{2}+b_{3} = 1$.
     [[file:image/Figure 9.16.png]]
     1. 三个顶点的表达式:
     $\boldsymbul{v_{1}} \equiv (1,0,0), \quad \boldsymbul{v_{1}} \equiv (0,1,0),\quad \boldsymbul{v_{1}} \equiv (0,0,1)$.
     2. 在顶点对边上的点,对应的顶点坐标值都为0.
     3. 所有在平面内的点都能在重心坐标上表示,而不只是三角形内的点.

     _Interpreting(b1,b2,) as ordinary 2D coordinates_
     这里还有一个代换技巧,考虑$b_{1}+b_{2}+b_{3} = 1$,则可以让 $b_{3} = 1 - b_{1} - b_{2}$.
     则有:
     $(b_{1},b_{2},b_{3}) \equiv b_{1} \boldsymbol{v_{1}} + b_{2} \boldsymbol{v_{2}} + b_{3} \boldsymbol{v_{3}}$
                         $\equiv b_{1} \boldsymbol{v_{1}} + b_{2} \boldsymbol{v_{2}} + (1 - b_{1} - b_{2}) \boldsymbol{v_{3}}$
                         $\equiv \boldsymbol{v_{3}} + b_{1}\boldsymbol{v_{1} - v_{3}} + b_{1}\boldsymbol{v_{2} - v_{3}}$
     由此我们可以推出一个结论:
     _The number of degrees of freedom = the number of barycentric coordinates -1._
     *重心坐标* 的主要作用: 1.) *插值*[interpolated] 2.) *相交检测*[intersection testing]
**** Calculating Barycentric Coordinates[计算重心坐标]
     [[file:image/Figure 9.17.png]]
     *重心坐标* --> *笛卡尔坐标*
    上图的参数分别为:
     顶点 $\boldsymbol{v_{1},v_{2},v_{3}}$,任意点 $\boldsymbol{p}$,被$\boldsymbol{p}$ 切分出来的三角形 $T_{1},T_{2},T_{3}$.有:

     $b_{1}x_{1} + b_{2}x_{2} + b_{3}x_{3}  = p_{x}$,
     $b_{1}y_{1} + b_{2}y_{2} + b_{3}y_{3}  = p_{x}$,
     $b_{1} + b_{2} + b_{3} = 1$.

    再根据上式求出重心坐标中的 $b_{1},b_{2},b_{3}$.

     $b_{1} = \frac{(p_{y} - y_{3}) (x_{2} - x_{3}) + (y_{2} - y_{3}) (x_{3} - p_{x})}{(y_{1} - y_{3}) (x_{2} - x_{3}) + (y_{2} - y_{3}) (x_{3} - x_{1})}$,

     $b_{2} = \frac{(p_{y} - y_{1}) (x_{3} - x_{1}) + (y_{3} - y_{1}) (x_{1} - p_{x})}{(y_{1} - y_{3}) (x_{2} - x_{3}) + (y_{2} - y_{3}) (x_{3} - x_{1})}$,

     $b_{3} = \frac{(p_{y} - y_{2}) (x_{1} - x_{2}) + (y_{1} - y_{2}) (x_{2} - p_{x})}{(y_{1} - y_{3}) (x_{2} - x_{3}) + (y_{2} - y_{3}) (x_{3} - x_{1})}$.
     
     _interpreting barycentric coordinates as ratio of areas_
       $\boldsymbol{A} = \frac{y_{1}(x_{2}-x_{3}) + y_{2}(x_{3}-x_{1}) + y_{3}(x_{1}-x_{2})}{2}$
            $= \frac{(y_{1}-y_{3})(x_{2}-x_{3}) + (y_{2}-y_{3})(x_{3}-x_{1}) + (y_{3}-y_{3})(x_{1}-x_{2})}{2}$
            $= \frac{(y_{1}-y_{3})(x_{2}-x_{3}) + (y_{2}-y_{3})(x_{3}-x_{1})}{2}$.
     观察上面两个式子可以发现,$b_{i}$ 的分母等于2A,换句话说,有:

     $b_{1} = A(T_{1})/A(T), \quad b_{2} = A(T_{2})/A(T), \quad b_{3} = A(T_{3})/A(T)$.

     其中两种情况值得关注.
     一是 p 在三角形外面,其实不影响,因为最终得到的面积是有符号数.
     一是三个点是共线的,这样会造成分母为0,无法进行计算.
     
     前面讨论的是在2D情况下的重心坐标,现在要考虑3D情况下的坐标.
     一种方法是使用向量的 *叉积*[cross product].但是问题在于向量的叉积的 *大小*[magnitude]不能为负,
这样就导致点在三角形外的情况不正常.解决方法如下:
     假设存在一个向量 $\boldsymbol{c}$,它是一个三角形的两个 *edge vectors* 的叉积结果.而 $\hat{n}$ 为垂直于平面的单位向量.
     $\boldsymbol{c \cdot \hat{n} = ||c|| ||\hat{n}|| cos \theta}$
                $= \boldsymbol{||c||} ||1|| (\pm 1)$
                $= \pm \boldsymbol{||c||}$
     [[file:image/Figure 9.18.png]]
     从上图可知,每个顶点都有一个从 $\boldsymbol{v_{i}}$ 到 $\boldsymbol{p}$ 的向量,被叫做 $\boldsymbol{d_{i}}$.
     $\boldsymbol{e_{1} = v_{3} - v_{2}, \quad e_{2} = v_{1} - v_{3}, \quad e_{3} = v_{2} - v_{1}}$,
     $\boldsymbol{d_{1} = p - v_{1}, \quad d_{2} = p - v_{2}, \quad d_{3} = p - v_{3}}$.
     
     _surface normal[平面法向量]_
     $\boldsymbol{ \hat{n} = \frac {e_{1} \times e_{2}} {||e_{1} \times e_{2}||} }$.

     由此,可得各个三角形面积为:
     $A(T) = \boldsymbol{((e_{1} \times e_{2}) \cdot \hat{n})/2}$,
     $A(T_{1}) = \boldsymbol{((e_{1} \times d_{3}) \cdot \hat{n})/2}$,
     $A(T_{2}) = \boldsymbol{((e_{2} \times d_{1}) \cdot \hat{n})/2}$,
     $A(T_{3}) = \boldsymbol{((e_{3} \times d_{2}) \cdot \hat{n})/2}$,
     
     既然各个三角形面积已经得到,则3D下的 *重心坐标* 可表示为:
     $b_{1} = A(T_{1})/A(T) = \boldsymbol{ \frac {((e_{1} \times d_{3}) \cdot \hat{n})} {((e_{1} \times e_{2}) \cdot \hat{n})}}$,
     $b_{2} = A(T_{2})/A(T) = \boldsymbol{ \frac {((e_{2} \times d_{1}) \cdot \hat{n})} {((e_{1} \times e_{2}) \cdot \hat{n})}}$,
     $b_{3} = A(T_{3})/A(T) = \boldsymbol{ \frac {((e_{3} \times d_{2}) \cdot \hat{n})} {((e_{1} \times e_{2}) \cdot \hat{n})}}$.
**** Special Points[特殊点]
     *center of gravity*[重心] --> *centroid*[几何中心] --> 中线的交点.
     [[file:image/Figure 9.19.png]]
     _The center of gravity_
     $\boldsymbol{c}_{Grav} = \frac{\boldsymbol{v_{1}+ v_{2}+ v_{3}}}{3}$.
     _The Barycentric coordinates_
     $(\frac{1}{3},\frac{1}{3},\frac{1}{3})$.
     
     *incenter*[内切圆心] --> 角平分线的交点.  --> 用于寻找三角形三边的切线.
     [[file:image/Figure 9.20.png]]
     _the incenter_
     $\boldsymbol{c}_{In} = \frac{ l_{1}\vec{v}_{1} + l_{2}\vec{v}_{2} + l_{3}\vec{v}_{3} }{p}, \quad p=l_{1}+l_{2}+l_{3}$.
     _radius of the inscribed circle_
     $r_{In} = \frac{A}{p}$. A-->Area[面积]

     *circumcenter*[外接圆心] --> 与三个顶点等距离的点,垂直等分三条边. -->用于寻找同时通过三个点的圆.
     [[file:image/Figure 9.21.png]]
     _define the intermediate values_
     $d_{1} = \boldsymbol{-e_{2} \cdot e_{3}}$,
     $d_{2} = \boldsymbol{-e_{3} \cdot e_{1}}$,
     $d_{3} = \boldsymbol{-e_{1} \cdot e_{2}}$,
     $c_{1} = d_{2}d_{3}$,
     $c_{2} = d_{3}d_{1}$,
     $c_{3} = d_{1}d_{2}$,
     $c = c_{1}+ c_{2}+ c_{3}$.

     _the barycentric coordinates for the circumcenter_
     $(\frac{c_{2}+c_{3}}{2c},\frac{c_{3}+c_{1}}{2c},\frac{c_{1}+c_{2}}{2c})$;

     _the circumcenter_
     $\boldsymbol{c}_{Circ} = \frac{(c_{2}+c_{3})\vec{v}_{1} + (c_{3}+c_{1})\vec{v}_{2} + (c_{1}+c_{2})\vec{v}_{3}}{2c}$.
     _the circumradius_
     $r_{Circ} = \frac{\sqrt{(d_{1}+d_{2})(d_{2}+d_{3})(d_{3}+d_{1}) /c }}{2}$.
*** 9.7 Polygons[多边形]
    Define : A polygon is _a flat object made up of vertices and edges_.
**** Simple versus Complex Polygons[简单多边形 vs 复杂多边形]
     Simple polygon --> 没有 *洞*[hole] 的多边形.
     Complex polygon --> 中间有 *洞*[hole] 的多边形.
     [[file:image/Figure 9.22.png]]
     
     Complex polygon --> Simple polygon
     添加 *seam edges*[缝合线?],如图:
     [[file:image/Figure 9.23.png]]
     
     Self-intersecting polygons[自交叉多边形]:
     [[file:image/Figure 9.24.png]]
**** Convex versus Concave Polygons[凸多边形 vs 凹多边形]
     *Non-self-intersecting*[非交叉]的简单多边形又能分为:
     1.) *Converx*[凸]多边形.
     2.) *Concave*[凹]多边形.
     *concavity*[凹面]
     
     [[file:image/Figure 9.25.png]]
     两者有如下区别:
     - *point of concavity*[凹点],一个凸多边形不会有任何 *凹点*[dents],一个凹多边形至少有一个凹点.
     - 对凸多边形而言,任意两个顶点间的线段都在多边形内部或边界上.而对凹多边形而言,至少有一对点所对
应的线段(至少有部分)在多边形外.
     - 当沿着一个凸多边形的顶点行走时,它要么顺时针要么逆时针运动,而沿凹多边形则不会.
     _Any concave polygon may be divided into convex pieces_
     
     如何确定一个多边形是凹还是凸? 
     _方法一.使用点积_
     设一个凸多边形有 $n$ 个角,则其内角和为 $(n-2)180^\circ$.
     首先,假设 $\theta_{i}$ 为顶点 $i$ 的内角,已知多边形为凸多边形,则有 $\theta_{i} \le 180^\circ$.对应角为 $180^\circ - \theta_{i}$,则有:
     $\sum_{i=1}^{n}(180^{\circ} -\theta_{i}) = 360^{\circ}$,
     $n180^{\circ} - \sum_{i=1}^{n}\theta_{i} = 360^{\circ}$,
                 $-\sum_{i=1}^{n}\theta{i} = 360^{\circ} - n180^{\circ}$,
                     $\sum_{i=1}^{n}\theta_{i} = n180^{\circ} - 360^{\circ}$,
                     $\sum_{i=1}^{n}\theta_{i} = (n-2)180^{\circ}$.
     其实将凸多边形分为 $(n-2)$ 个三角形也能计算...
     然而问题在于凹多边形的内角和也满足这个条件.

     [[file:image/Figure 9.26.png]]
     如图,
     1.) 点积总是计算最小角.
     2.) 多边形任意顶点的内外角的和相加为 $360^{\circ}$.
     3.) 凸多边形每个角都小于$180^{\circ}$.凹多边形却不确定.
     由上述条件得出 _结论_,
     点积后的角之和若 _等于_  $(n-2)180^{\circ}$,则必然为 *凸多边形*. 
     _小于_ 则必然为 *凹多边形*.
     
     _方法二,查找 *凹点*[points of  concavity]_.
**** Triangulation and Fanning[三角化和?]
     _Any polygon can be divided into triangles_.
     _Triangulating a convex polygon by fanning_
     [[file:image/Figure 9.27.png]]
** Chapter 10 Mathematical Topics from 3D graphics[3D图形学中的数学]
*** 10.1 How Graphics Work[图形如何运作]
    Concepts to learn:
    *diffuse maps*[漫反射贴图]
    *Blinn-Phong shading*[Blinn-Phong 着色]
    *ambient occlusion*[环境光遮蔽] --> *AO*
    _How rendering really works?_
**** The Two Major Approaches to Rendering[渲染的两个主要目的]

     _The end goal of rendering_
     --> is a *bitmap*[位图] / a sequence of *bitmaps* if we are producing an animation.
     *bitmap*[位图] --> a rectangular array of colors,and each grid entry is known as *pixel*.
     *pixel*[像素] --> picture element.
     *frame buffer*[帧缓冲] <----> *bitmap*
     
     _fundamental question of rendering_
     --> is how do we determine the color of each pixel?

     _the rendering algorithm_:
      - _visible surface determination_[可见面检测]
        找到眼睛能看到的最近的 *表面*[surface],其方向与当前像素对应.
      - _Lighting_[光照]
        确定从眼睛的方向上看到的光 *发射*[emitted] 和/或 *反射*[reflected off]的表面.
     1. _visible surface determination_
        a. *raytracing*[光线追踪] 不是要从发射出的表面的方向开始追踪光线,而是只关注我们眼睛能接受
到的方向上的光.我们从眼睛发出一道射线,方向通过每个像素点的中心以观察场景中第一个被射线击中的
物体.
        伪代码如下:
        [[file:image/Listing 9.4.png]]
        b. *depth buffering*[深度缓冲]
        每一个像素点不仅存储颜色,还要存储一个 *depth value*[深度值].
        *depth value* : 从眼睛到物体表面的距离.
        伪代码如下:
        [[file:image/Listing 9.5.png]]
     用什么方法来描述 *表面*[surface]在这里并不重要,更重要的是,我们可以将 *表面* 投影到 *屏幕空间*
[screen space],并且通过 *光栅化*[rasterization]来将 *表面* 的像素映射到 *屏幕空间* 的像素.
     *source fragment* --> *destination fragment* ---> *forward rendering*
     在表面上的像素点,被叫做 *source fragment*,它有一个 *depth value*,而 *depth buffer* 上的像素点
被叫做 *destination fragment*,同样有一个 *depth value*.
     通过将两个 *depth value* 对比, *depth buffer* 中永远只保存最小的 *depth value* 值,最终只需要将
最小的 *depth value* 的像素的颜色 *渲染*[rendering]出来, _这个过程就叫 forward rendering_.
     
     c. *deferred rendering*[延迟渲染]
    考虑到性能瓶颈问题, *deferred rendering* 再次流行起来.
     *G-buffer*[G-缓冲],G for Geometric -> 包含一系列额外信息的缓冲区(3D表面坐标/表面法线/材质属
性).
    具体步骤如下:
    1.) 将场景渲染到G-buffer,只做 *visibility determination*,不做 *lighting calculations*.
    2.) 执行 *lighting calculations*.
    [[file:image/Listing 10.3.png]]
**** Describling Surface Properties: The BRDF[表面的属性:BRDF]
     渲染的第二步: *Lighting*[光照].
     首先,要确定光是 1.) _直接从表面发出的_,还是 2.) _由其他物体发出的光反射到表面再进入人的眼睛_.
     第 1.)种,如 _灯,太阳_. 第 2.)种,才是我们主要关注的情况.

     *BRDF*[双向反射分布函数](Bidirectional Reflectance Distribution Function). 
     --> 我们应该问的不是 _这个物体是什么颜色?_,而是 _反射的光是如何分布的?_.
     --> 因为我们看到的物体的光其实是其他颜色的光打在物体上反射/折射到我们眼睛里看到的效果.
     --> 
     *BRDF* 函数: $f\boldsymbol{(x,\hat{\omega}_{in},\hat{\omega}_{out}},\lambda)$.
     1.) $x$ 表示光的 _起始点_;
     2.) $\boldsymbol{\hat{\omega}_{in}}}$ 为一个 *单位向量*,表示光的 _入射方向_;
     3.) $\boldsymbol{\hat{\omega}_{out}}}$ 表示 _出射方向_;
     4.) $\lambda$ 则是光的 _颜色_.
     总结
     1.) *BRDF* 通过 $\lambda$ 来解释两个物体间 *颜色*[color]的差异: _任何给定波长的光都有自己的反射率分布_.
     2.) *BRDF* 通过 $\boldsymbol{\hat{\omega}_{in}}},\boldsymbol{\hat{\omega}_{out}}}$ 来解释两个物体间 *亮度*[shininess] 的差异.

     *shiny* 反射光 <--> *diffuse* 漫射光
     1.) A _shiny surface_ reflects *incident light*[入射光] more strongly in one particular direction compared
to others.
     2.) A _diffuse surface_ scatters[散射] light more evevnly across all *outgoing directions*[出射方向].
     
     *BSSDF*[双向表面散射分布函数](Bidirectional Surface Scattering Distribution Function)
     --> *半透明*[translucence] 和 *光线折射*[light refraction]可以通过允许方向向量指回表面来合并.

     *subsurface scattering*[次表面散射] --> 光穿过透明物体表面后,与 *材料*[material]之间发生交互作用
而导致光被散射开来.(光一般会穿透物体的表面,在物体内部不同角度被反射若干次,最终穿出物体).
     通常可以用于渲染 *皮肤*[skin], *牛奶*[milk], *大理石*, *树叶*, *蜡* 等.

     *BSDF* (Bidirectional Scattering Distribution Function) --> 没有 _Surface_,表示不止在表面上,而是空间里.
     --> 用来做雾气效果,次表面散射等.
     
     _Helmholtz reciprocity_
     $f\boldsymbol{(x,\hat{\omega}_{1},\hat{\omega}_{2}},\lambda) = f\boldsymbol{(x,\hat{\omega}_{2},\hat{\omega}_{1}},\lambda)$.
     由于光沿直线传播,且入射角等于反射角,考虑到对称性,从哪儿进到哪儿出并不重要.
**** A Very Brief Introduction to Colorimetry and Radiometry[简介:色度学&辐射度学]
     图形学的所有都是关于如何测量光.
     1.) 如何测量光的 *颜色*[color].
     2.) 如何测量它的 *亮度*[brightness].
     
     _Key Points about Color_
     - 光的光谱分布是一个连续函数,而不只是RGB.只是就人类对光的感知程度而言,用RGB表示已经足够了.
     - RGB不是唯一的 *颜色空间*[color space],同样也不一定适合于所有情况,只是对于人而言能满足需求.
     
     _Common radiometric terms_
     | *Quantity*[名称]                                           | *Units*[单位]                                                        | *SI unit*[符号]           | *Translation*[简介]                     |
     | Radiant energy[辐射能]                                 | Energy[能量]                                                         | J[焦耳]                       | 某段间隔时间内的总照明量                |
     | Radiant flux[辐射通量]                                  | Power[功率]                                                          | W[瓦特]                     | 从四处汇聚于某个面积内的光的亮度        |
     | Radiant flux density[辐射通量密度]               | Power per unit area[单位面积功率]                        | W/m^{2}                   | 从四处汇聚于某个点的光的亮度            |
     | Irradiance[辐照度]                                        | Power per unit area[单位面积功率]                        | W/m^{2}                   | *入射光*[incident light] 的辐射通量密度 |
     | Radiant exitance[辐出度]                              | Power per unit area[单位面积功率]                         | W/m^{2}                  | *发射光*[emitted light] 的辐射通量密度  |
     | Radiosity[辐射度]                                          | Power per unit[单位面积功率]                                | W/m^{2}                   | 发射光/反射光的辐射通量密度             |
     | Radiance[辐射率]                                          | Power per unit projected area,per unit solid angle  | W/(m^{2} \cdot sr)    | *射线*[ray] 的亮度                      |
     
     *solid angle*[立体角]  < --- > *regular angle*[平面角]
     立体角描述 _站在某一点的观察者测量到的物体大小的尺度_
     以观测点为球心,构造一个 *单位球面*;任意物体投影到该球面上的 *投影面积*,就是该物体对于该观测点
的立体角.
     立体角是 _单位球面上的一块面积_.
     立体角的单位是 *steradian*[球面度],简写为 "sr".
     
     _Key Points about Radiometry_
     - 在可以使用辐射度量的专业术语时,最好避免使用模糊的定义如 *亮度*[intensity] 和 *明度*[brightness].
     - 使用 *辐射通量*[radiant flux]来测量有限区域内的亮度.
     - 使用 *辐射通量密度*[radiant flux density]来测量某个点的亮度.
        a. *辐照度*[Irradiance] --> *入射光*[incident] 的辐射通量密度.
        b. *辐出度*[radiant exitance] --> *发射光*[emitted]的辐射通量密度.
        c. *辐射度*[radiosity] --> 离开表面的光的辐射通量密度(无论是反射光还是发射光).
     - 根据 *Lambert's law*,相对于倾斜角度的平面,给定光在垂直的平面会有更大的辐照度差.
     - 使用 *辐射率*[radiance]来测量一个射线的明度.
**** The Rendering Equation[渲染方程]
     在计算机图形学中, *渲染方程*[rendering equation]描述了光能在场景中的流动.其基础是能量守恒定律.
     
     _The Rendering Equation_
     $\boldsymbol{L_{out}(X,\hat{\omega}_{out},\lambda) = L_{emis}(X,\hat{\omega}_{out},\lambda) +}$
                                            $\boldsymbol{\int_{\omega} L_{in}(X,\hat{\omega}_{in},\lambda)f(X,\hat{\omega}_{in},\hat{\omega}_{out},\lambda)(-\hat{\omega}_{in} \cdot \hat{n})d\hat{\omega}_{in}}$.
     现在来解释下这个公式到底什么意思:)
     $\boldsymbol{ L_{out} (X,\hat{\omega}_{out},\lambda)}$
        ->在 _1.)特定位置$\boldsymbol{X}$_ 及 _2.)方向 $\boldsymbol{\hat{w}}_{out}$_ 的出射光.
     $\boldsymbol{ L_{emis} (X,\hat{\omega}_{out},\lambda)}$ 
        -> 从位置 $\boldsymbol{X}$ 和方向 $\boldsymbol{\hat{w}}_{out}$ 发出的光.
     $\boldsymbol{\int_{\omega} L_{in}(X,\hat{\omega}_{in},\lambda)f(X,\hat{\omega}_{in},\hat{\omega}_{out},\lambda)(-\hat{\omega}_{in} \cdot \hat{n})d\hat{\omega}_{in}}$ 
        -> 从位置 $\boldsymbol{X}$ 和方向 $\boldsymbol{\hat{w}}_{out}$ 反射出的光.
     
     总结一下就是:
     出射光 $\boldsymbol{\hat{w}}_{out}$ = 发射光$\boldsymbol{\hat{w}}_{emis}$ + 反射光 .
     
     现在来具体解释反射光的方程(如果你现在还不懂 *微积分*[calculus],只需要把 *积分*[integral]替换成
     *求和*[sum],完全不影响你的理解).
     反射光的方程可分解如下:
     
* Footnotes

[fn:singularity] 在数学中,表示 _数学物件中无法处理的点_.

[fn:surfacenormal] 三维平面的法线是 _垂直_ 于该平面的 *三维向量*.法线是与多边形的曲面垂直的理论线.

[fn:worldspace] 在南方人/北方人指路的时候,北方人往往告诉你,往北面/南面走,而南方人则是沿着这儿到
下个路口往左/往右,可见北方人采用的世界坐标系,而南方人采用的是对象坐标系.

[fn:norm] 
要更好的理解范数,就要从 _函数、几何与矩阵_ 的角度去理解,我尽量讲的通俗一些。
我们都知道,函数与几何图形往往是有对应的关系,这个很好想象,特别是在三维以下的空间内,
函数是几何图像的数学概括,而几何图像是函数的高度形象化,比如一个函数对应几何空间
上若干点组成的图形。
但当函数与几何超出三维空间时,就难以获得较好的想象,于是就有了 *映射* 的概念,映射表达
的就是 _一个集合通过某种关系转为另外一个集合_
通常数学书是先说映射,然后再讨论函数,这是因为 _函数是映射的一个特例_,为了更好的在数学
上表达这种映射关系,（这里特指线性关系）于是就引进了矩阵。
这里的矩阵就是表征上述空间映射的 *线性关系*. 而通过向量来表示上述映射中所说的这个集合,
而我    们通常所说的 *基* ,就是这个集合的最一般关系。
于是,我们可以这样理解,一个集合（向量）,通过一种映射关系（矩阵）,得到另外一个几何（另外
一个向量）。
那么向量的范数，就是表示这个 _原有集合的大小_ 。
而矩    阵的范数,就是表示这个 _变化过程的大小的一个度量_ 。
那么说到具体    几几范数，其不过是定义不同,一个矩阵范数往往由一个向量范数引出,我们称之为
*算子范数*,其物理意义都如我上述所述。
0范数,向量中非零元素的个数
1范数,为绝对值之和
2范数,就是通常意义上的模
无穷范数,就是取向量的最大值

